/*
 * generated by Xtext 2.26.0
 */
package org.xtext.pascal.program.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.pascal.program.demoFkd.DemoFkdPackage;
import org.xtext.pascal.program.demoFkd.abstraction_declaration;
import org.xtext.pascal.program.demoFkd.abstraction_heading;
import org.xtext.pascal.program.demoFkd.any_number;
import org.xtext.pascal.program.demoFkd.array_type;
import org.xtext.pascal.program.demoFkd.assignment_statement;
import org.xtext.pascal.program.demoFkd.block;
import org.xtext.pascal.program.demoFkd.bound_specification;
import org.xtext.pascal.program.demoFkd.case_label_list;
import org.xtext.pascal.program.demoFkd.case_limb;
import org.xtext.pascal.program.demoFkd.case_statement;
import org.xtext.pascal.program.demoFkd.class_type;
import org.xtext.pascal.program.demoFkd.compound_statement;
import org.xtext.pascal.program.demoFkd.conditional_statement;
import org.xtext.pascal.program.demoFkd.conformant_array_schema;
import org.xtext.pascal.program.demoFkd.constant;
import org.xtext.pascal.program.demoFkd.constant_definition;
import org.xtext.pascal.program.demoFkd.constant_definition_part;
import org.xtext.pascal.program.demoFkd.dynamic_array_type;
import org.xtext.pascal.program.demoFkd.enumerated_type;
import org.xtext.pascal.program.demoFkd.expression;
import org.xtext.pascal.program.demoFkd.expression_list;
import org.xtext.pascal.program.demoFkd.factor;
import org.xtext.pascal.program.demoFkd.field_list;
import org.xtext.pascal.program.demoFkd.file_type;
import org.xtext.pascal.program.demoFkd.fixed_part;
import org.xtext.pascal.program.demoFkd.for_statement;
import org.xtext.pascal.program.demoFkd.formal_parameter_list;
import org.xtext.pascal.program.demoFkd.formal_parameter_section;
import org.xtext.pascal.program.demoFkd.function_designator;
import org.xtext.pascal.program.demoFkd.goto_statement;
import org.xtext.pascal.program.demoFkd.identifier_list;
import org.xtext.pascal.program.demoFkd.if_statement;
import org.xtext.pascal.program.demoFkd.index_type;
import org.xtext.pascal.program.demoFkd.label;
import org.xtext.pascal.program.demoFkd.label_declaration_part;
import org.xtext.pascal.program.demoFkd.member_list;
import org.xtext.pascal.program.demoFkd.number;
import org.xtext.pascal.program.demoFkd.packed_conformant_array_schema;
import org.xtext.pascal.program.demoFkd.parameter_type;
import org.xtext.pascal.program.demoFkd.pascal;
import org.xtext.pascal.program.demoFkd.pointer_type;
import org.xtext.pascal.program.demoFkd.procedure_and_function_declaration_part;
import org.xtext.pascal.program.demoFkd.program;
import org.xtext.pascal.program.demoFkd.program_heading_block;
import org.xtext.pascal.program.demoFkd.properties_part;
import org.xtext.pascal.program.demoFkd.property_list;
import org.xtext.pascal.program.demoFkd.property_section;
import org.xtext.pascal.program.demoFkd.record_section;
import org.xtext.pascal.program.demoFkd.record_type;
import org.xtext.pascal.program.demoFkd.repeat_statement;
import org.xtext.pascal.program.demoFkd.repetitive_statement;
import org.xtext.pascal.program.demoFkd.set;
import org.xtext.pascal.program.demoFkd.set_type;
import org.xtext.pascal.program.demoFkd.simple_expression;
import org.xtext.pascal.program.demoFkd.simple_statement;
import org.xtext.pascal.program.demoFkd.simple_type;
import org.xtext.pascal.program.demoFkd.statement;
import org.xtext.pascal.program.demoFkd.statement_part;
import org.xtext.pascal.program.demoFkd.statement_sequence;
import org.xtext.pascal.program.demoFkd.structured_statement;
import org.xtext.pascal.program.demoFkd.structured_type;
import org.xtext.pascal.program.demoFkd.subrange_type;
import org.xtext.pascal.program.demoFkd.tag_field;
import org.xtext.pascal.program.demoFkd.term;
import org.xtext.pascal.program.demoFkd.type;
import org.xtext.pascal.program.demoFkd.type_definition;
import org.xtext.pascal.program.demoFkd.type_definition_part;
import org.xtext.pascal.program.demoFkd.unpacked_conformant_array_schema;
import org.xtext.pascal.program.demoFkd.unpacked_structured_type;
import org.xtext.pascal.program.demoFkd.uses_command_definition_part;
import org.xtext.pascal.program.demoFkd.value_parameter_section;
import org.xtext.pascal.program.demoFkd.var_;
import org.xtext.pascal.program.demoFkd.variable;
import org.xtext.pascal.program.demoFkd.variable_declaration_part;
import org.xtext.pascal.program.demoFkd.variable_identifier_list;
import org.xtext.pascal.program.demoFkd.variable_parameter_section;
import org.xtext.pascal.program.demoFkd.variable_section;
import org.xtext.pascal.program.demoFkd.variant;
import org.xtext.pascal.program.demoFkd.variant_part;
import org.xtext.pascal.program.demoFkd.while_statement;
import org.xtext.pascal.program.demoFkd.with_statement;
import org.xtext.pascal.program.services.DemoFkdGrammarAccess;

@SuppressWarnings("all")
public class DemoFkdSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DemoFkdGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DemoFkdPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DemoFkdPackage.ABSTRACTION_DECLARATION:
				sequence_function_declaration(context, (abstraction_declaration) semanticObject); 
				return; 
			case DemoFkdPackage.ABSTRACTION_HEADING:
				if (rule == grammarAccess.getFunction_headingRule()) {
					sequence_function_heading(context, (abstraction_heading) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstraction_headingRule()) {
					sequence_function_heading_procedure_heading(context, (abstraction_heading) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstraction_declarationRule()
						|| rule == grammarAccess.getProcedure_declarationRule()) {
					sequence_procedure_declaration(context, (abstraction_heading) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProcedure_headingRule()) {
					sequence_procedure_heading(context, (abstraction_heading) semanticObject); 
					return; 
				}
				else break;
			case DemoFkdPackage.ANY_NUMBER:
				if (rule == grammarAccess.getSigned_numberRule()) {
					sequence_signed_number(context, (any_number) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAny_numberRule()) {
					sequence_signed_number_unsigned_number(context, (any_number) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnsigned_numberRule()) {
					sequence_unsigned_number(context, (any_number) semanticObject); 
					return; 
				}
				else break;
			case DemoFkdPackage.ARRAY_TYPE:
				sequence_array_type(context, (array_type) semanticObject); 
				return; 
			case DemoFkdPackage.ASSIGNMENT_STATEMENT:
				sequence_assignment_statement(context, (assignment_statement) semanticObject); 
				return; 
			case DemoFkdPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case DemoFkdPackage.BOUND_SPECIFICATION:
				sequence_bound_specification(context, (bound_specification) semanticObject); 
				return; 
			case DemoFkdPackage.CASE_LABEL_LIST:
				sequence_case_label_list(context, (case_label_list) semanticObject); 
				return; 
			case DemoFkdPackage.CASE_LIMB:
				sequence_case_limb(context, (case_limb) semanticObject); 
				return; 
			case DemoFkdPackage.CASE_STATEMENT:
				sequence_case_statement(context, (case_statement) semanticObject); 
				return; 
			case DemoFkdPackage.CLASS_TYPE:
				sequence_class_type(context, (class_type) semanticObject); 
				return; 
			case DemoFkdPackage.COMPOUND_STATEMENT:
				sequence_compound_statement(context, (compound_statement) semanticObject); 
				return; 
			case DemoFkdPackage.CONDITIONAL_STATEMENT:
				sequence_conditional_statement(context, (conditional_statement) semanticObject); 
				return; 
			case DemoFkdPackage.CONFORMANT_ARRAY_SCHEMA:
				sequence_conformant_array_schema(context, (conformant_array_schema) semanticObject); 
				return; 
			case DemoFkdPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case DemoFkdPackage.CONSTANT_DEFINITION:
				sequence_constant_definition(context, (constant_definition) semanticObject); 
				return; 
			case DemoFkdPackage.CONSTANT_DEFINITION_PART:
				sequence_constant_definition_part(context, (constant_definition_part) semanticObject); 
				return; 
			case DemoFkdPackage.DYNAMIC_ARRAY_TYPE:
				sequence_dynamic_array_type(context, (dynamic_array_type) semanticObject); 
				return; 
			case DemoFkdPackage.ENUMERATED_TYPE:
				sequence_enumerated_type(context, (enumerated_type) semanticObject); 
				return; 
			case DemoFkdPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case DemoFkdPackage.EXPRESSION_LIST:
				sequence_expression_list(context, (expression_list) semanticObject); 
				return; 
			case DemoFkdPackage.FACTOR:
				sequence_factor(context, (factor) semanticObject); 
				return; 
			case DemoFkdPackage.FIELD_LIST:
				sequence_field_list(context, (field_list) semanticObject); 
				return; 
			case DemoFkdPackage.FILE_TYPE:
				sequence_file_type(context, (file_type) semanticObject); 
				return; 
			case DemoFkdPackage.FIXED_PART:
				sequence_fixed_part(context, (fixed_part) semanticObject); 
				return; 
			case DemoFkdPackage.FOR_STATEMENT:
				sequence_for_statement(context, (for_statement) semanticObject); 
				return; 
			case DemoFkdPackage.FORMAL_PARAMETER_LIST:
				sequence_formal_parameter_list(context, (formal_parameter_list) semanticObject); 
				return; 
			case DemoFkdPackage.FORMAL_PARAMETER_SECTION:
				sequence_formal_parameter_section(context, (formal_parameter_section) semanticObject); 
				return; 
			case DemoFkdPackage.FUNCTION_DESIGNATOR:
				sequence_function_designator(context, (function_designator) semanticObject); 
				return; 
			case DemoFkdPackage.GOTO_STATEMENT:
				sequence_goto_statement(context, (goto_statement) semanticObject); 
				return; 
			case DemoFkdPackage.IDENTIFIER_LIST:
				sequence_identifier_list(context, (identifier_list) semanticObject); 
				return; 
			case DemoFkdPackage.IF_STATEMENT:
				sequence_if_statement(context, (if_statement) semanticObject); 
				return; 
			case DemoFkdPackage.INDEX_TYPE:
				sequence_index_type(context, (index_type) semanticObject); 
				return; 
			case DemoFkdPackage.LABEL:
				sequence_label(context, (label) semanticObject); 
				return; 
			case DemoFkdPackage.LABEL_DECLARATION_PART:
				sequence_label_declaration_part(context, (label_declaration_part) semanticObject); 
				return; 
			case DemoFkdPackage.MEMBER_LIST:
				sequence_member_list(context, (member_list) semanticObject); 
				return; 
			case DemoFkdPackage.NUMBER:
				sequence_number(context, (number) semanticObject); 
				return; 
			case DemoFkdPackage.PACKED_CONFORMANT_ARRAY_SCHEMA:
				sequence_packed_conformant_array_schema(context, (packed_conformant_array_schema) semanticObject); 
				return; 
			case DemoFkdPackage.PARAMETER_TYPE:
				sequence_parameter_type(context, (parameter_type) semanticObject); 
				return; 
			case DemoFkdPackage.PASCAL:
				sequence_pascal(context, (pascal) semanticObject); 
				return; 
			case DemoFkdPackage.POINTER_TYPE:
				sequence_pointer_type(context, (pointer_type) semanticObject); 
				return; 
			case DemoFkdPackage.PROCEDURE_AND_FUNCTION_DECLARATION_PART:
				sequence_procedure_and_function_declaration_part(context, (procedure_and_function_declaration_part) semanticObject); 
				return; 
			case DemoFkdPackage.PROGRAM:
				sequence_program(context, (program) semanticObject); 
				return; 
			case DemoFkdPackage.PROGRAM_HEADING_BLOCK:
				sequence_program_heading_block(context, (program_heading_block) semanticObject); 
				return; 
			case DemoFkdPackage.PROPERTIES_PART:
				if (rule == grammarAccess.getMember_listRule()) {
					sequence_member_list_properties_part(context, (properties_part) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProperties_partRule()) {
					sequence_properties_part(context, (properties_part) semanticObject); 
					return; 
				}
				else break;
			case DemoFkdPackage.PROPERTY_LIST:
				sequence_property_list(context, (property_list) semanticObject); 
				return; 
			case DemoFkdPackage.PROPERTY_SECTION:
				sequence_property_section(context, (property_section) semanticObject); 
				return; 
			case DemoFkdPackage.RECORD_SECTION:
				sequence_record_section(context, (record_section) semanticObject); 
				return; 
			case DemoFkdPackage.RECORD_TYPE:
				sequence_record_type(context, (record_type) semanticObject); 
				return; 
			case DemoFkdPackage.REPEAT_STATEMENT:
				sequence_repeat_statement(context, (repeat_statement) semanticObject); 
				return; 
			case DemoFkdPackage.REPETITIVE_STATEMENT:
				sequence_repetitive_statement(context, (repetitive_statement) semanticObject); 
				return; 
			case DemoFkdPackage.SET:
				sequence_set(context, (set) semanticObject); 
				return; 
			case DemoFkdPackage.SET_TYPE:
				sequence_set_type(context, (set_type) semanticObject); 
				return; 
			case DemoFkdPackage.SIMPLE_EXPRESSION:
				sequence_simple_expression(context, (simple_expression) semanticObject); 
				return; 
			case DemoFkdPackage.SIMPLE_STATEMENT:
				sequence_simple_statement(context, (simple_statement) semanticObject); 
				return; 
			case DemoFkdPackage.SIMPLE_TYPE:
				sequence_simple_type(context, (simple_type) semanticObject); 
				return; 
			case DemoFkdPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case DemoFkdPackage.STATEMENT_PART:
				sequence_statement_part(context, (statement_part) semanticObject); 
				return; 
			case DemoFkdPackage.STATEMENT_SEQUENCE:
				sequence_statement_sequence(context, (statement_sequence) semanticObject); 
				return; 
			case DemoFkdPackage.STRUCTURED_STATEMENT:
				sequence_structured_statement(context, (structured_statement) semanticObject); 
				return; 
			case DemoFkdPackage.STRUCTURED_TYPE:
				sequence_structured_type(context, (structured_type) semanticObject); 
				return; 
			case DemoFkdPackage.SUBRANGE_TYPE:
				sequence_subrange_type(context, (subrange_type) semanticObject); 
				return; 
			case DemoFkdPackage.TAG_FIELD:
				sequence_tag_field(context, (tag_field) semanticObject); 
				return; 
			case DemoFkdPackage.TERM:
				sequence_term(context, (term) semanticObject); 
				return; 
			case DemoFkdPackage.TYPE:
				sequence_type(context, (type) semanticObject); 
				return; 
			case DemoFkdPackage.TYPE_DEFINITION:
				sequence_type_definition(context, (type_definition) semanticObject); 
				return; 
			case DemoFkdPackage.TYPE_DEFINITION_PART:
				sequence_type_definition_part(context, (type_definition_part) semanticObject); 
				return; 
			case DemoFkdPackage.UNPACKED_CONFORMANT_ARRAY_SCHEMA:
				sequence_unpacked_conformant_array_schema(context, (unpacked_conformant_array_schema) semanticObject); 
				return; 
			case DemoFkdPackage.UNPACKED_STRUCTURED_TYPE:
				sequence_unpacked_structured_type(context, (unpacked_structured_type) semanticObject); 
				return; 
			case DemoFkdPackage.USES_COMMAND_DEFINITION_PART:
				sequence_uses_command_definition_part(context, (uses_command_definition_part) semanticObject); 
				return; 
			case DemoFkdPackage.VALUE_PARAMETER_SECTION:
				sequence_value_parameter_section(context, (value_parameter_section) semanticObject); 
				return; 
			case DemoFkdPackage.VAR_:
				sequence_var_(context, (var_) semanticObject); 
				return; 
			case DemoFkdPackage.VARIABLE:
				sequence_variable(context, (variable) semanticObject); 
				return; 
			case DemoFkdPackage.VARIABLE_DECLARATION_PART:
				sequence_variable_declaration_part(context, (variable_declaration_part) semanticObject); 
				return; 
			case DemoFkdPackage.VARIABLE_IDENTIFIER_LIST:
				sequence_variable_identifier_list(context, (variable_identifier_list) semanticObject); 
				return; 
			case DemoFkdPackage.VARIABLE_PARAMETER_SECTION:
				sequence_variable_parameter_section(context, (variable_parameter_section) semanticObject); 
				return; 
			case DemoFkdPackage.VARIABLE_SECTION:
				sequence_variable_section(context, (variable_section) semanticObject); 
				return; 
			case DemoFkdPackage.VARIANT:
				sequence_variant(context, (variant) semanticObject); 
				return; 
			case DemoFkdPackage.VARIANT_PART:
				sequence_variant_part(context, (variant_part) semanticObject); 
				return; 
			case DemoFkdPackage.WHILE_STATEMENT:
				sequence_while_statement(context, (while_statement) semanticObject); 
				return; 
			case DemoFkdPackage.WITH_STATEMENT:
				sequence_with_statement(context, (with_statement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     array_type returns array_type
	 *
	 * Constraint:
	 *     (indexes+=index_type indexes+=index_type* type=type)
	 * </pre>
	 */
	protected void sequence_array_type(ISerializationContext context, array_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     assignment_statement returns assignment_statement
	 *
	 * Constraint:
	 *     (variable=variable expression=expression)
	 * </pre>
	 */
	protected void sequence_assignment_statement(ISerializationContext context, assignment_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignment_statementAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignment_statementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     (
	 *         uses_command=uses_command_definition_part? 
	 *         label=label_declaration_part? 
	 *         constant=constant_definition_part? 
	 *         type=type_definition_part? 
	 *         variable=variable_declaration_part? 
	 *         abstraction=procedure_and_function_declaration_part? 
	 *         statement=statement_part
	 *     )
	 * </pre>
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     bound_specification returns bound_specification
	 *
	 * Constraint:
	 *     (initial=ID final=ID name=ID)
	 * </pre>
	 */
	protected void sequence_bound_specification(ISerializationContext context, bound_specification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.BOUND_SPECIFICATION__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.BOUND_SPECIFICATION__INITIAL));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.BOUND_SPECIFICATION__FINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.BOUND_SPECIFICATION__FINAL));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.BOUND_SPECIFICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.BOUND_SPECIFICATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBound_specificationAccess().getInitialIDTerminalRuleCall_0_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getBound_specificationAccess().getFinalIDTerminalRuleCall_2_0(), semanticObject.getFinal());
		feeder.accept(grammarAccess.getBound_specificationAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     case_label_list returns case_label_list
	 *
	 * Constraint:
	 *     (constants+=constant constants+=constant*)
	 * </pre>
	 */
	protected void sequence_case_label_list(ISerializationContext context, case_label_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     case_limb returns case_limb
	 *
	 * Constraint:
	 *     (cases=case_label_list statement=statement)
	 * </pre>
	 */
	protected void sequence_case_limb(ISerializationContext context, case_limb semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.CASE_LIMB__CASES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.CASE_LIMB__CASES));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.CASE_LIMB__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.CASE_LIMB__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCase_limbAccess().getCasesCase_label_listParserRuleCall_0_0(), semanticObject.getCases());
		feeder.accept(grammarAccess.getCase_limbAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     case_statement returns case_statement
	 *
	 * Constraint:
	 *     (expression=expression cases+=case_limb cases+=case_limb*)
	 * </pre>
	 */
	protected void sequence_case_statement(ISerializationContext context, case_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     class_type returns class_type
	 *
	 * Constraint:
	 *     (classKeyword='class' members=member_list? endKeyword='end')
	 * </pre>
	 */
	protected void sequence_class_type(ISerializationContext context, class_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     compound_statement returns compound_statement
	 *
	 * Constraint:
	 *     sequence=statement_sequence
	 * </pre>
	 */
	protected void sequence_compound_statement(ISerializationContext context, compound_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.COMPOUND_STATEMENT__SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.COMPOUND_STATEMENT__SEQUENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompound_statementAccess().getSequenceStatement_sequenceParserRuleCall_1_0(), semanticObject.getSequence());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     conditional_statement returns conditional_statement
	 *
	 * Constraint:
	 *     (ifStmt=if_statement | caseStmt=case_statement)
	 * </pre>
	 */
	protected void sequence_conditional_statement(ISerializationContext context, conditional_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     conformant_array_schema returns conformant_array_schema
	 *
	 * Constraint:
	 *     (packed=packed_conformant_array_schema | unpacked=unpacked_conformant_array_schema)
	 * </pre>
	 */
	protected void sequence_conformant_array_schema(ISerializationContext context, conformant_array_schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     ((opterator=ADDITION_OPERATOR? (name=ID | number=number)) | string=STRING | boolLiteral='true' | boolLiteral='false' | nil='nil')
	 * </pre>
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     constant_definition returns constant_definition
	 *
	 * Constraint:
	 *     (name=ID const=constant)
	 * </pre>
	 */
	protected void sequence_constant_definition(ISerializationContext context, constant_definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.CONSTANT_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.CONSTANT_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.CONSTANT_DEFINITION__CONST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.CONSTANT_DEFINITION__CONST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstant_definitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstant_definitionAccess().getConstConstantParserRuleCall_2_0(), semanticObject.getConst());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     constant_definition_part returns constant_definition_part
	 *
	 * Constraint:
	 *     consts+=constant_definition+
	 * </pre>
	 */
	protected void sequence_constant_definition_part(ISerializationContext context, constant_definition_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     dynamic_array_type returns dynamic_array_type
	 *
	 * Constraint:
	 *     type=type
	 * </pre>
	 */
	protected void sequence_dynamic_array_type(ISerializationContext context, dynamic_array_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.DYNAMIC_ARRAY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.DYNAMIC_ARRAY_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDynamic_array_typeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     enumerated_type returns enumerated_type
	 *
	 * Constraint:
	 *     identifiers=identifier_list
	 * </pre>
	 */
	protected void sequence_enumerated_type(ISerializationContext context, enumerated_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.ENUMERATED_TYPE__IDENTIFIERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.ENUMERATED_TYPE__IDENTIFIERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerated_typeAccess().getIdentifiersIdentifier_listParserRuleCall_1_0(), semanticObject.getIdentifiers());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (expressions+=simple_expression ((operators+=RELATIONAL_OPERATOR | operators+='in' | operators+='=') expressions+=simple_expression)?)
	 * </pre>
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     expression_list returns expression_list
	 *
	 * Constraint:
	 *     (expressions+=expression expressions+=expression*)
	 * </pre>
	 */
	protected void sequence_expression_list(ISerializationContext context, expression_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     factor returns factor
	 *
	 * Constraint:
	 *     (
	 *         variable=variable | 
	 *         number=number | 
	 *         string=STRING | 
	 *         set=set | 
	 *         nil?='nil' | 
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         function=function_designator | 
	 *         expression=expression | 
	 *         not=factor
	 *     )
	 * </pre>
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     field_list returns field_list
	 *
	 * Constraint:
	 *     ((fixed=fixed_part variants+=variant_part?) | variants+=variant_part)
	 * </pre>
	 */
	protected void sequence_field_list(ISerializationContext context, field_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     file_type returns file_type
	 *
	 * Constraint:
	 *     type=type
	 * </pre>
	 */
	protected void sequence_file_type(ISerializationContext context, file_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.FILE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.FILE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFile_typeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     fixed_part returns fixed_part
	 *
	 * Constraint:
	 *     (sections+=record_section sections+=record_section*)
	 * </pre>
	 */
	protected void sequence_fixed_part(ISerializationContext context, fixed_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     for_statement returns for_statement
	 *
	 * Constraint:
	 *     (assignment=assignment_statement expression=expression statement=statement)
	 * </pre>
	 */
	protected void sequence_for_statement(ISerializationContext context, for_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.FOR_STATEMENT__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.FOR_STATEMENT__ASSIGNMENT));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.FOR_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.FOR_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.FOR_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.FOR_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFor_statementAccess().getAssignmentAssignment_statementParserRuleCall_1_0(), semanticObject.getAssignment());
		feeder.accept(grammarAccess.getFor_statementAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getFor_statementAccess().getStatementStatementParserRuleCall_5_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     formal_parameter_list returns formal_parameter_list
	 *
	 * Constraint:
	 *     (parameters+=formal_parameter_section parameters+=formal_parameter_section*)
	 * </pre>
	 */
	protected void sequence_formal_parameter_list(ISerializationContext context, formal_parameter_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     formal_parameter_section returns formal_parameter_section
	 *
	 * Constraint:
	 *     (value=value_parameter_section | variable=variable_parameter_section | procedure=procedure_heading | function=function_heading)
	 * </pre>
	 */
	protected void sequence_formal_parameter_section(ISerializationContext context, formal_parameter_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     abstraction_declaration returns abstraction_declaration
	 *     function_declaration returns abstraction_declaration
	 *
	 * Constraint:
	 *     (heading=function_heading (block=block | forward?='forward'))
	 * </pre>
	 */
	protected void sequence_function_declaration(ISerializationContext context, abstraction_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     function_designator returns function_designator
	 *
	 * Constraint:
	 *     (name=ID expressions=expression_list?)
	 * </pre>
	 */
	protected void sequence_function_designator(ISerializationContext context, function_designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     function_heading returns abstraction_heading
	 *
	 * Constraint:
	 *     (name=ID parameters=formal_parameter_list? returnType=ID)
	 * </pre>
	 */
	protected void sequence_function_heading(ISerializationContext context, abstraction_heading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     abstraction_heading returns abstraction_heading
	 *
	 * Constraint:
	 *     ((name=ID parameters=formal_parameter_list?) | (name=ID parameters=formal_parameter_list? returnType=ID))
	 * </pre>
	 */
	protected void sequence_function_heading_procedure_heading(ISerializationContext context, abstraction_heading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     goto_statement returns goto_statement
	 *
	 * Constraint:
	 *     label=label
	 * </pre>
	 */
	protected void sequence_goto_statement(ISerializationContext context, goto_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.GOTO_STATEMENT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.GOTO_STATEMENT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoto_statementAccess().getLabelLabelParserRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     identifier_list returns identifier_list
	 *
	 * Constraint:
	 *     (names+=ID names+=ID*)
	 * </pre>
	 */
	protected void sequence_identifier_list(ISerializationContext context, identifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     if_statement returns if_statement
	 *
	 * Constraint:
	 *     (expression=expression ifStatement=statement elseStatement=statement?)
	 * </pre>
	 */
	protected void sequence_if_statement(ISerializationContext context, if_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     index_type returns index_type
	 *
	 * Constraint:
	 *     type=simple_type
	 * </pre>
	 */
	protected void sequence_index_type(ISerializationContext context, index_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.INDEX_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.INDEX_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndex_typeAccess().getTypeSimple_typeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     label_declaration_part returns label_declaration_part
	 *
	 * Constraint:
	 *     (labels+=label labels+=label*)
	 * </pre>
	 */
	protected void sequence_label_declaration_part(ISerializationContext context, label_declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     label returns label
	 *
	 * Constraint:
	 *     (number=SIGNED_INTEGER_NUMBER | number=INTEGER_NUMBER)
	 * </pre>
	 */
	protected void sequence_label(ISerializationContext context, label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     member_list returns member_list
	 *
	 * Constraint:
	 *     methods+=method_part
	 * </pre>
	 */
	protected void sequence_member_list(ISerializationContext context, member_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     member_list returns properties_part
	 *
	 * Constraint:
	 *     (visibility=VISIBILITY_SUPPORTED sections+=property_section sections+=property_section* methods+=method_part?)
	 * </pre>
	 */
	protected void sequence_member_list_properties_part(ISerializationContext context, properties_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     number returns number
	 *
	 * Constraint:
	 *     number=any_number
	 * </pre>
	 */
	protected void sequence_number(ISerializationContext context, number semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.NUMBER__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.NUMBER__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberAccess().getNumberAny_numberParserRuleCall_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     packed_conformant_array_schema returns packed_conformant_array_schema
	 *
	 * Constraint:
	 *     (bound=bound_specification name=ID)
	 * </pre>
	 */
	protected void sequence_packed_conformant_array_schema(ISerializationContext context, packed_conformant_array_schema semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__BOUND));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.PACKED_CONFORMANT_ARRAY_SCHEMA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPacked_conformant_array_schemaAccess().getBoundBound_specificationParserRuleCall_3_0(), semanticObject.getBound());
		feeder.accept(grammarAccess.getPacked_conformant_array_schemaAccess().getNameIDTerminalRuleCall_6_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     parameter_type returns parameter_type
	 *
	 * Constraint:
	 *     (array=conformant_array_schema | name=ID)
	 * </pre>
	 */
	protected void sequence_parameter_type(ISerializationContext context, parameter_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     pascal returns pascal
	 *
	 * Constraint:
	 *     program+=program
	 * </pre>
	 */
	protected void sequence_pascal(ISerializationContext context, pascal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     pointer_type returns pointer_type
	 *
	 * Constraint:
	 *     type=type
	 * </pre>
	 */
	protected void sequence_pointer_type(ISerializationContext context, pointer_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.POINTER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.POINTER_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointer_typeAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     method_part returns procedure_and_function_declaration_part
	 *     procedure_and_function_declaration_part returns procedure_and_function_declaration_part
	 *
	 * Constraint:
	 *     (procedures+=procedure_declaration | functions+=function_declaration)+
	 * </pre>
	 */
	protected void sequence_procedure_and_function_declaration_part(ISerializationContext context, procedure_and_function_declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     abstraction_declaration returns abstraction_heading
	 *     procedure_declaration returns abstraction_heading
	 *
	 * Constraint:
	 *     (heading=procedure_heading (block=block | forward?='forward'))
	 * </pre>
	 */
	protected void sequence_procedure_declaration(ISerializationContext context, abstraction_heading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     procedure_heading returns abstraction_heading
	 *
	 * Constraint:
	 *     (name=ID parameters=formal_parameter_list?)
	 * </pre>
	 */
	protected void sequence_procedure_heading(ISerializationContext context, abstraction_heading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     program_heading_block returns program_heading_block
	 *
	 * Constraint:
	 *     (name=ID identifiers=identifier_list?)
	 * </pre>
	 */
	protected void sequence_program_heading_block(ISerializationContext context, program_heading_block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     program returns program
	 *
	 * Constraint:
	 *     (heading=program_heading_block block=block)
	 * </pre>
	 */
	protected void sequence_program(ISerializationContext context, program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.PROGRAM__HEADING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.PROGRAM__HEADING));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.PROGRAM__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.PROGRAM__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getHeadingProgram_heading_blockParserRuleCall_0_0(), semanticObject.getHeading());
		feeder.accept(grammarAccess.getProgramAccess().getBlockBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     properties_part returns properties_part
	 *
	 * Constraint:
	 *     (visibility=VISIBILITY_SUPPORTED sections+=property_section sections+=property_section*)
	 * </pre>
	 */
	protected void sequence_properties_part(ISerializationContext context, properties_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     property_list returns property_list
	 *
	 * Constraint:
	 *     (names+=ID names+=ID*)
	 * </pre>
	 */
	protected void sequence_property_list(ISerializationContext context, property_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     property_section returns property_section
	 *
	 * Constraint:
	 *     (properties=property_list type=type)
	 * </pre>
	 */
	protected void sequence_property_section(ISerializationContext context, property_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.PROPERTY_SECTION__PROPERTIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.PROPERTY_SECTION__PROPERTIES));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.PROPERTY_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.PROPERTY_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProperty_sectionAccess().getPropertiesProperty_listParserRuleCall_0_0(), semanticObject.getProperties());
		feeder.accept(grammarAccess.getProperty_sectionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     record_section returns record_section
	 *
	 * Constraint:
	 *     (identifiers=identifier_list type=type)
	 * </pre>
	 */
	protected void sequence_record_section(ISerializationContext context, record_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.RECORD_SECTION__IDENTIFIERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.RECORD_SECTION__IDENTIFIERS));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.RECORD_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.RECORD_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecord_sectionAccess().getIdentifiersIdentifier_listParserRuleCall_0_0(), semanticObject.getIdentifiers());
		feeder.accept(grammarAccess.getRecord_sectionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     record_type returns record_type
	 *
	 * Constraint:
	 *     (recordKeyword='record' fields=field_list? endKeyword='end')
	 * </pre>
	 */
	protected void sequence_record_type(ISerializationContext context, record_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     repeat_statement returns repeat_statement
	 *
	 * Constraint:
	 *     (sequence=statement_sequence expression=expression)
	 * </pre>
	 */
	protected void sequence_repeat_statement(ISerializationContext context, repeat_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.REPEAT_STATEMENT__SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.REPEAT_STATEMENT__SEQUENCE));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.REPEAT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.REPEAT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeat_statementAccess().getSequenceStatement_sequenceParserRuleCall_1_0(), semanticObject.getSequence());
		feeder.accept(grammarAccess.getRepeat_statementAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     repetitive_statement returns repetitive_statement
	 *
	 * Constraint:
	 *     (whileStmt=while_statement | repeatStmt=repeat_statement | forStmt=for_statement)
	 * </pre>
	 */
	protected void sequence_repetitive_statement(ISerializationContext context, repetitive_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     set returns set
	 *
	 * Constraint:
	 *     (brackets+='[' expressions=expression_list? brackets+=']')
	 * </pre>
	 */
	protected void sequence_set(ISerializationContext context, set semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     set_type returns set_type
	 *
	 * Constraint:
	 *     type=type
	 * </pre>
	 */
	protected void sequence_set_type(ISerializationContext context, set_type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.SET_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.SET_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSet_typeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     signed_number returns any_number
	 *
	 * Constraint:
	 *     (integer=SIGNED_INTEGER_NUMBER | real=SIGNED_REAL_NUMBER)
	 * </pre>
	 */
	protected void sequence_signed_number(ISerializationContext context, any_number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     any_number returns any_number
	 *
	 * Constraint:
	 *     (integer=INTEGER_NUMBER | real=REAL_NUMBER | integer=SIGNED_INTEGER_NUMBER | real=SIGNED_REAL_NUMBER)
	 * </pre>
	 */
	protected void sequence_signed_number_unsigned_number(ISerializationContext context, any_number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     simple_expression returns simple_expression
	 *
	 * Constraint:
	 *     (prefixOperator=ADDITION_OPERATOR? terms+=term (terms+=unsigned_number? ((operators+=ADDITION_OPERATOR | operators+='or') terms+=term)?)+)
	 * </pre>
	 */
	protected void sequence_simple_expression(ISerializationContext context, simple_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     simple_statement returns simple_statement
	 *
	 * Constraint:
	 *     (assignment=assignment_statement | function=function_designator | goto=goto_statement | function_noargs=ID)
	 * </pre>
	 */
	protected void sequence_simple_statement(ISerializationContext context, simple_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     simple_type returns simple_type
	 *
	 * Constraint:
	 *     (subrange=subrange_type | enumerated=enumerated_type | name=ID)
	 * </pre>
	 */
	protected void sequence_simple_type(ISerializationContext context, simple_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     statement_part returns statement_part
	 *
	 * Constraint:
	 *     sequence=statement_sequence
	 * </pre>
	 */
	protected void sequence_statement_part(ISerializationContext context, statement_part semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.STATEMENT_PART__SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.STATEMENT_PART__SEQUENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatement_partAccess().getSequenceStatement_sequenceParserRuleCall_1_0(), semanticObject.getSequence());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     statement_sequence returns statement_sequence
	 *
	 * Constraint:
	 *     (statements+=statement statements+=statement*)
	 * </pre>
	 */
	protected void sequence_statement_sequence(ISerializationContext context, statement_sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (label=label? (simple=simple_statement | structured=structured_statement))
	 * </pre>
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     structured_statement returns structured_statement
	 *
	 * Constraint:
	 *     (compound=compound_statement | repetitive=repetitive_statement | conditional=conditional_statement | withStmt=with_statement)
	 * </pre>
	 */
	protected void sequence_structured_statement(ISerializationContext context, structured_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     structured_type returns structured_type
	 *
	 * Constraint:
	 *     (packed?='packed'? type=unpacked_structured_type)
	 * </pre>
	 */
	protected void sequence_structured_type(ISerializationContext context, structured_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     subrange_type returns subrange_type
	 *
	 * Constraint:
	 *     ((initialConst=constant finalConst=constant) | (subrange=NUMERIC_SUBRANGE const=constant))
	 * </pre>
	 */
	protected void sequence_subrange_type(ISerializationContext context, subrange_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     tag_field returns tag_field
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_tag_field(ISerializationContext context, tag_field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.TAG_FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.TAG_FIELD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTag_fieldAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     term returns term
	 *
	 * Constraint:
	 *     (factors+=factor ((operators+=MULTIPLICATION_OPERATOR | operators+='div' | operators+='mod' | operators+='and') factors+=factor)*)
	 * </pre>
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     type_definition_part returns type_definition_part
	 *
	 * Constraint:
	 *     types+=type_definition+
	 * </pre>
	 */
	protected void sequence_type_definition_part(ISerializationContext context, type_definition_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     type_definition returns type_definition
	 *
	 * Constraint:
	 *     (name=ID type=type)
	 * </pre>
	 */
	protected void sequence_type_definition(ISerializationContext context, type_definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.TYPE_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.TYPE_DEFINITION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_definitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getType_definitionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     type returns type
	 *
	 * Constraint:
	 *     (simple=simple_type | structured=structured_type | pointer=pointer_type)
	 * </pre>
	 */
	protected void sequence_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     unpacked_conformant_array_schema returns unpacked_conformant_array_schema
	 *
	 * Constraint:
	 *     (bounds+=bound_specification bounds+=bound_specification* type=parameter_type)
	 * </pre>
	 */
	protected void sequence_unpacked_conformant_array_schema(ISerializationContext context, unpacked_conformant_array_schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     unpacked_structured_type returns unpacked_structured_type
	 *
	 * Constraint:
	 *     (
	 *         array=array_type | 
	 *         dynamic=dynamic_array_type | 
	 *         record=record_type | 
	 *         set=set_type | 
	 *         file=file_type | 
	 *         class=class_type
	 *     )
	 * </pre>
	 */
	protected void sequence_unpacked_structured_type(ISerializationContext context, unpacked_structured_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     unsigned_number returns any_number
	 *
	 * Constraint:
	 *     (integer=INTEGER_NUMBER | real=REAL_NUMBER)
	 * </pre>
	 */
	protected void sequence_unsigned_number(ISerializationContext context, any_number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     uses_command_definition_part returns uses_command_definition_part
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)
	 * </pre>
	 */
	protected void sequence_uses_command_definition_part(ISerializationContext context, uses_command_definition_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     value_parameter_section returns value_parameter_section
	 *
	 * Constraint:
	 *     (identifiers=identifier_list type=parameter_type)
	 * </pre>
	 */
	protected void sequence_value_parameter_section(ISerializationContext context, value_parameter_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VALUE_PARAMETER_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VALUE_PARAMETER_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValue_parameter_sectionAccess().getIdentifiersIdentifier_listParserRuleCall_0_0(), semanticObject.getIdentifiers());
		feeder.accept(grammarAccess.getValue_parameter_sectionAccess().getTypeParameter_typeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     var_ returns var_
	 *
	 * Constraint:
	 *     ((expressions=expression_list array=var_) | (accessor?='.' name=ID variable=var_) | pointer=var_)
	 * </pre>
	 */
	protected void sequence_var_(ISerializationContext context, var_ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variable_declaration_part returns variable_declaration_part
	 *
	 * Constraint:
	 *     (sections+=variable_section sections+=variable_section*)
	 * </pre>
	 */
	protected void sequence_variable_declaration_part(ISerializationContext context, variable_declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variable_identifier_list returns variable_identifier_list
	 *
	 * Constraint:
	 *     (names+=ID names+=ID*)
	 * </pre>
	 */
	protected void sequence_variable_identifier_list(ISerializationContext context, variable_identifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variable_parameter_section returns variable_parameter_section
	 *
	 * Constraint:
	 *     (identifiers=identifier_list type=parameter_type)
	 * </pre>
	 */
	protected void sequence_variable_parameter_section(ISerializationContext context, variable_parameter_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VARIABLE_PARAMETER_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VARIABLE_PARAMETER_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariable_parameter_sectionAccess().getIdentifiersIdentifier_listParserRuleCall_1_0(), semanticObject.getIdentifiers());
		feeder.accept(grammarAccess.getVariable_parameter_sectionAccess().getTypeParameter_typeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variable_section returns variable_section
	 *
	 * Constraint:
	 *     (identifiers=variable_identifier_list type=type)
	 * </pre>
	 */
	protected void sequence_variable_section(ISerializationContext context, variable_section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VARIABLE_SECTION__IDENTIFIERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VARIABLE_SECTION__IDENTIFIERS));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VARIABLE_SECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VARIABLE_SECTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariable_sectionAccess().getIdentifiersVariable_identifier_listParserRuleCall_0_0(), semanticObject.getIdentifiers());
		feeder.accept(grammarAccess.getVariable_sectionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variable returns variable
	 *
	 * Constraint:
	 *     (name=ID variable=var_)
	 * </pre>
	 */
	protected void sequence_variable(ISerializationContext context, variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getVariableVar_ParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variant_part returns variant_part
	 *
	 * Constraint:
	 *     (tag=tag_field? name=ID variants+=variant variants+=variant*)
	 * </pre>
	 */
	protected void sequence_variant_part(ISerializationContext context, variant_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     variant returns variant
	 *
	 * Constraint:
	 *     (labels=case_label_list fields=field_list?)
	 * </pre>
	 */
	protected void sequence_variant(ISerializationContext context, variant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     while_statement returns while_statement
	 *
	 * Constraint:
	 *     (expression=expression statement=statement)
	 * </pre>
	 */
	protected void sequence_while_statement(ISerializationContext context, while_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.WHILE_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, DemoFkdPackage.Literals.WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DemoFkdPackage.Literals.WHILE_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhile_statementAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhile_statementAccess().getStatementStatementParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     with_statement returns with_statement
	 *
	 * Constraint:
	 *     (variables+=variable variables+=variable* statement=statement)
	 * </pre>
	 */
	protected void sequence_with_statement(ISerializationContext context, with_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

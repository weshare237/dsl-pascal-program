/*
 * generated by Xtext 2.26.0
 */
package org.xtext.pascal.program.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class DemoFkdGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class PascalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.pascal");
		private final Assignment cProgramAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cProgramProgramParserRuleCall_0 = (RuleCall)cProgramAssignment.eContents().get(0);
		
		//pascal:
		//    program += program
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//program += program
		public Assignment getProgramAssignment() { return cProgramAssignment; }
		
		//program
		public RuleCall getProgramProgramParserRuleCall_0() { return cProgramProgramParserRuleCall_0; }
	}
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadingAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadingProgram_heading_blockParserRuleCall_0_0 = (RuleCall)cHeadingAssignment_0.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//program:
		//    heading=program_heading_block block=block "."
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//heading=program_heading_block block=block "."
		public Group getGroup() { return cGroup; }
		
		//heading=program_heading_block
		public Assignment getHeadingAssignment_0() { return cHeadingAssignment_0; }
		
		//program_heading_block
		public RuleCall getHeadingProgram_heading_blockParserRuleCall_0_0() { return cHeadingProgram_heading_blockParserRuleCall_0_0; }
		
		//block=block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }
		
		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}
	public class Program_heading_blockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.program_heading_block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProgramKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIdentifiersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIdentifiersIdentifier_listParserRuleCall_2_1_0 = (RuleCall)cIdentifiersAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//program_heading_block: //TODO: this parameter was added as optional
		//    "program" name=ID ( "(" identifiers=identifier_list ")" ) ? ";"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: this parameter was added as optional
		//   "program" name=ID ( "(" identifiers=identifier_list ")" ) ? ";"
		public Group getGroup() { return cGroup; }
		
		////TODO: this parameter was added as optional
		//   "program"
		public Keyword getProgramKeyword_0() { return cProgramKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//( "(" identifiers=identifier_list ")" ) ?
		public Group getGroup_2() { return cGroup_2; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//identifiers=identifier_list
		public Assignment getIdentifiersAssignment_2_1() { return cIdentifiersAssignment_2_1; }
		
		//identifier_list
		public RuleCall getIdentifiersIdentifier_listParserRuleCall_2_1_0() { return cIdentifiersIdentifier_listParserRuleCall_2_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class Identifier_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.identifier_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_1_0 = (RuleCall)cNamesAssignment_1_1.eContents().get(0);
		
		//identifier_list:
		//    names+=ID ( "," names+=ID ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID ( "," names+=ID ) *
		public Group getGroup() { return cGroup; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//( "," names+=ID ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_1_1() { return cNamesAssignment_1_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_1_0() { return cNamesIDTerminalRuleCall_1_1_0; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelLabel_declaration_partParserRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Assignment cConstantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstantConstant_definition_partParserRuleCall_1_0 = (RuleCall)cConstantAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeType_definition_partParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableVariable_declaration_partParserRuleCall_3_0 = (RuleCall)cVariableAssignment_3.eContents().get(0);
		private final Assignment cAbstractionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAbstractionProcedure_and_function_declaration_partParserRuleCall_4_0 = (RuleCall)cAbstractionAssignment_4.eContents().get(0);
		private final Assignment cStatementAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementStatement_partParserRuleCall_5_0 = (RuleCall)cStatementAssignment_5.eContents().get(0);
		
		//block: //TODO: INLINE DECLARATION PART
		//    ( label=label_declaration_part ) ?
		//    ( constant=constant_definition_part ) ?
		//    ( type=type_definition_part ) ?
		//    ( variable=variable_declaration_part ) ?
		//    ( abstraction=procedure_and_function_declaration_part ) ?
		//    statement=statement_part
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: INLINE DECLARATION PART
		//   ( label=label_declaration_part ) ?
		//   ( constant=constant_definition_part ) ?
		//   ( type=type_definition_part ) ?
		//   ( variable=variable_declaration_part ) ?
		//   ( abstraction=procedure_and_function_declaration_part ) ?
		//   statement=statement_part
		public Group getGroup() { return cGroup; }
		
		////TODO: INLINE DECLARATION PART
		//   ( label=label_declaration_part ) ?
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }
		
		//label_declaration_part
		public RuleCall getLabelLabel_declaration_partParserRuleCall_0_0() { return cLabelLabel_declaration_partParserRuleCall_0_0; }
		
		//( constant=constant_definition_part ) ?
		public Assignment getConstantAssignment_1() { return cConstantAssignment_1; }
		
		//constant_definition_part
		public RuleCall getConstantConstant_definition_partParserRuleCall_1_0() { return cConstantConstant_definition_partParserRuleCall_1_0; }
		
		//( type=type_definition_part ) ?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type_definition_part
		public RuleCall getTypeType_definition_partParserRuleCall_2_0() { return cTypeType_definition_partParserRuleCall_2_0; }
		
		//( variable=variable_declaration_part ) ?
		public Assignment getVariableAssignment_3() { return cVariableAssignment_3; }
		
		//variable_declaration_part
		public RuleCall getVariableVariable_declaration_partParserRuleCall_3_0() { return cVariableVariable_declaration_partParserRuleCall_3_0; }
		
		//( abstraction=procedure_and_function_declaration_part ) ?
		public Assignment getAbstractionAssignment_4() { return cAbstractionAssignment_4; }
		
		//procedure_and_function_declaration_part
		public RuleCall getAbstractionProcedure_and_function_declaration_partParserRuleCall_4_0() { return cAbstractionProcedure_and_function_declaration_partParserRuleCall_4_0; }
		
		//statement=statement_part
		public Assignment getStatementAssignment_5() { return cStatementAssignment_5; }
		
		//statement_part
		public RuleCall getStatementStatement_partParserRuleCall_5_0() { return cStatementStatement_partParserRuleCall_5_0; }
	}
	public class Statement_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.statement_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBeginKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSequenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSequenceStatement_sequenceParserRuleCall_1_0 = (RuleCall)cSequenceAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//statement_part:
		//    "begin" sequence=statement_sequence "end"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"begin" sequence=statement_sequence "end"
		public Group getGroup() { return cGroup; }
		
		//"begin"
		public Keyword getBeginKeyword_0() { return cBeginKeyword_0; }
		
		//sequence=statement_sequence
		public Assignment getSequenceAssignment_1() { return cSequenceAssignment_1; }
		
		//statement_sequence
		public RuleCall getSequenceStatement_sequenceParserRuleCall_1_0() { return cSequenceStatement_sequenceParserRuleCall_1_0; }
		
		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}
	public class Statement_sequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.statement_sequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_0_0 = (RuleCall)cStatementsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_1_0 = (RuleCall)cStatementsAssignment_1_1.eContents().get(0);
		
		//statement_sequence:
		//    statements+=statement ( ";" statements+=statement ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=statement ( ";" statements+=statement ) *
		public Group getGroup() { return cGroup; }
		
		//statements+=statement
		public Assignment getStatementsAssignment_0() { return cStatementsAssignment_0; }
		
		//statement
		public RuleCall getStatementsStatementParserRuleCall_0_0() { return cStatementsStatementParserRuleCall_0_0; }
		
		//( ";" statements+=statement ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }
		
		//statements+=statement
		public Assignment getStatementsAssignment_1_1() { return cStatementsAssignment_1_1; }
		
		//statement
		public RuleCall getStatementsStatementParserRuleCall_1_1_0() { return cStatementsStatementParserRuleCall_1_1_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSimpleAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cSimpleSimple_statementParserRuleCall_1_0_0 = (RuleCall)cSimpleAssignment_1_0.eContents().get(0);
		private final Assignment cStructuredAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cStructuredStructured_statementParserRuleCall_1_1_0 = (RuleCall)cStructuredAssignment_1_1.eContents().get(0);
		
		//statement:
		//    ( label=label ":" ) ? ( simple=simple_statement | structured=structured_statement )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//( label=label ":" ) ? ( simple=simple_statement | structured=structured_statement )
		public Group getGroup() { return cGroup; }
		
		//( label=label ":" ) ?
		public Group getGroup_0() { return cGroup_0; }
		
		//label=label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }
		
		//label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }
		
		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }
		
		//( simple=simple_statement | structured=structured_statement )
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//simple=simple_statement
		public Assignment getSimpleAssignment_1_0() { return cSimpleAssignment_1_0; }
		
		//simple_statement
		public RuleCall getSimpleSimple_statementParserRuleCall_1_0_0() { return cSimpleSimple_statementParserRuleCall_1_0_0; }
		
		//structured=structured_statement
		public Assignment getStructuredAssignment_1_1() { return cStructuredAssignment_1_1; }
		
		//structured_statement
		public RuleCall getStructuredStructured_statementParserRuleCall_1_1_0() { return cStructuredStructured_statementParserRuleCall_1_1_0; }
	}
	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.label");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumberSIGNED_INTEGER_NUMBERTerminalRuleCall_0_0 = (RuleCall)cNumberAssignment_0.eContents().get(0);
		private final Assignment cNumberAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNumberINTEGER_NUMBERTerminalRuleCall_1_0 = (RuleCall)cNumberAssignment_1.eContents().get(0);
		
		//label:
		//    number=SIGNED_INTEGER_NUMBER | number=INTEGER_NUMBER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//number=SIGNED_INTEGER_NUMBER | number=INTEGER_NUMBER
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//number=SIGNED_INTEGER_NUMBER
		public Assignment getNumberAssignment_0() { return cNumberAssignment_0; }
		
		//SIGNED_INTEGER_NUMBER
		public RuleCall getNumberSIGNED_INTEGER_NUMBERTerminalRuleCall_0_0() { return cNumberSIGNED_INTEGER_NUMBERTerminalRuleCall_0_0; }
		
		//number=INTEGER_NUMBER
		public Assignment getNumberAssignment_1() { return cNumberAssignment_1; }
		
		//INTEGER_NUMBER
		public RuleCall getNumberINTEGER_NUMBERTerminalRuleCall_1_0() { return cNumberINTEGER_NUMBERTerminalRuleCall_1_0; }
	}
	public class Simple_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.simple_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAssignmentAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentAssignment_statementParserRuleCall_0_0 = (RuleCall)cAssignmentAssignment_0.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionFunction_designatorParserRuleCall_1_0 = (RuleCall)cFunctionAssignment_1.eContents().get(0);
		private final Assignment cGotoAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cGotoGoto_statementParserRuleCall_2_0 = (RuleCall)cGotoAssignment_2.eContents().get(0);
		private final Assignment cFunction_noargsAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cFunction_noargsIDTerminalRuleCall_3_0 = (RuleCall)cFunction_noargsAssignment_3.eContents().get(0);
		
		//simple_statement: //TODO: PARAMETER ID WAS ADDED (FUNCTION DESIGNATOR WITHOUT PARAMETER)
		//    ( assignment=assignment_statement | function=function_designator | goto=goto_statement | function_noargs=ID ) ?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: PARAMETER ID WAS ADDED (FUNCTION DESIGNATOR WITHOUT PARAMETER)
		//   ( assignment=assignment_statement | function=function_designator | goto=goto_statement | function_noargs=ID ) ?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//assignment=assignment_statement
		public Assignment getAssignmentAssignment_0() { return cAssignmentAssignment_0; }
		
		//assignment_statement
		public RuleCall getAssignmentAssignment_statementParserRuleCall_0_0() { return cAssignmentAssignment_statementParserRuleCall_0_0; }
		
		//function=function_designator
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }
		
		//function_designator
		public RuleCall getFunctionFunction_designatorParserRuleCall_1_0() { return cFunctionFunction_designatorParserRuleCall_1_0; }
		
		//goto=goto_statement
		public Assignment getGotoAssignment_2() { return cGotoAssignment_2; }
		
		//goto_statement
		public RuleCall getGotoGoto_statementParserRuleCall_2_0() { return cGotoGoto_statementParserRuleCall_2_0; }
		
		//function_noargs=ID
		public Assignment getFunction_noargsAssignment_3() { return cFunction_noargsAssignment_3; }
		
		//ID
		public RuleCall getFunction_noargsIDTerminalRuleCall_3_0() { return cFunction_noargsIDTerminalRuleCall_3_0; }
	}
	public class Assignment_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.assignment_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//assignment_statement:
		//    variable=variable ":=" expression=expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=variable ":=" expression=expression
		public Group getGroup() { return cGroup; }
		
		//variable=variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }
		
		//expression=expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVar_ParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		
		//variable: //MISSING REFERENCED_VARIABLE BUT I THINK IT WORKS
		//    name=ID variable=var_
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////MISSING REFERENCED_VARIABLE BUT I THINK IT WORKS
		//   name=ID variable=var_
		public Group getGroup() { return cGroup; }
		
		////MISSING REFERENCED_VARIABLE BUT I THINK IT WORKS
		//   name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//variable=var_
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//var_
		public RuleCall getVariableVar_ParserRuleCall_1_0() { return cVariableVar_ParserRuleCall_1_0; }
	}
	public class Var_Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.var_");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cExpressionsAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cExpressionsExpression_listParserRuleCall_0_1_0 = (RuleCall)cExpressionsAssignment_0_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cArrayAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cArrayVar_ParserRuleCall_0_3_0 = (RuleCall)cArrayAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cAccessorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cAccessorFullStopKeyword_1_0_0 = (Keyword)cAccessorAssignment_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Assignment cVariableAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cVariableVar_ParserRuleCall_1_2_0 = (RuleCall)cVariableAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cCircumflexAccentKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPointerAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPointerVar_ParserRuleCall_2_1_0 = (RuleCall)cPointerAssignment_2_1.eContents().get(0);
		
		//var_: //TODO: REMOVED LEFT RECURSION (ERA COMPONENT_VARIABLE)
		//    ( "[" expressions=expression_list "]" array=var_ | accessor?="." name=ID variable=var_ | "^" pointer=var_ ) ?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: REMOVED LEFT RECURSION (ERA COMPONENT_VARIABLE)
		//   ( "[" expressions=expression_list "]" array=var_ | accessor?="." name=ID variable=var_ | "^" pointer=var_ ) ?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"[" expressions=expression_list "]" array=var_
		public Group getGroup_0() { return cGroup_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0_0() { return cLeftSquareBracketKeyword_0_0; }
		
		//expressions=expression_list
		public Assignment getExpressionsAssignment_0_1() { return cExpressionsAssignment_0_1; }
		
		//expression_list
		public RuleCall getExpressionsExpression_listParserRuleCall_0_1_0() { return cExpressionsExpression_listParserRuleCall_0_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_0_2() { return cRightSquareBracketKeyword_0_2; }
		
		//array=var_
		public Assignment getArrayAssignment_0_3() { return cArrayAssignment_0_3; }
		
		//var_
		public RuleCall getArrayVar_ParserRuleCall_0_3_0() { return cArrayVar_ParserRuleCall_0_3_0; }
		
		//accessor?="." name=ID variable=var_
		public Group getGroup_1() { return cGroup_1; }
		
		//accessor?="."
		public Assignment getAccessorAssignment_1_0() { return cAccessorAssignment_1_0; }
		
		//"."
		public Keyword getAccessorFullStopKeyword_1_0_0() { return cAccessorFullStopKeyword_1_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_1_0() { return cNameIDTerminalRuleCall_1_1_0; }
		
		//variable=var_
		public Assignment getVariableAssignment_1_2() { return cVariableAssignment_1_2; }
		
		//var_
		public RuleCall getVariableVar_ParserRuleCall_1_2_0() { return cVariableVar_ParserRuleCall_1_2_0; }
		
		//"^" pointer=var_
		public Group getGroup_2() { return cGroup_2; }
		
		//"^"
		public Keyword getCircumflexAccentKeyword_2_0() { return cCircumflexAccentKeyword_2_0; }
		
		//pointer=var_
		public Assignment getPointerAssignment_2_1() { return cPointerAssignment_2_1; }
		
		//var_
		public RuleCall getPointerVar_ParserRuleCall_2_1_0() { return cPointerVar_ParserRuleCall_2_1_0; }
	}
	public class Expression_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.expression_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//expression_list:
		//    expressions+=expression ( "," expressions+=expression ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//expressions+=expression ( "," expressions+=expression ) *
		public Group getGroup() { return cGroup; }
		
		//expressions+=expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }
		
		//expression
		public RuleCall getExpressionsExpressionParserRuleCall_0_0() { return cExpressionsExpressionParserRuleCall_0_0; }
		
		//( "," expressions+=expression ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//expressions+=expression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsSimple_expressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_0 = (Assignment)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cOperatorsRELATIONAL_OPERATORTerminalRuleCall_1_0_0_0 = (RuleCall)cOperatorsAssignment_1_0_0.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_1 = (Assignment)cAlternatives_1_0.eContents().get(1);
		private final Keyword cOperatorsInKeyword_1_0_1_0 = (Keyword)cOperatorsAssignment_1_0_1.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_2 = (Assignment)cAlternatives_1_0.eContents().get(2);
		private final Keyword cOperatorsEqualsSignKeyword_1_0_2_0 = (Keyword)cOperatorsAssignment_1_0_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsSimple_expressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//expression: //TODO: ADDED "=" PQ WAS NOT ACKNOWLEDGING IN RELATIONAL_OPERATOR
		//    expressions+=simple_expression ( ( operators+=RELATIONAL_OPERATOR | operators+="in" | operators+="=" ) expressions+=simple_expression ) ?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: ADDED "=" PQ WAS NOT ACKNOWLEDGING IN RELATIONAL_OPERATOR
		//   expressions+=simple_expression ( ( operators+=RELATIONAL_OPERATOR | operators+="in" | operators+="=" ) expressions+=simple_expression ) ?
		public Group getGroup() { return cGroup; }
		
		////TODO: ADDED "=" PQ WAS NOT ACKNOWLEDGING IN RELATIONAL_OPERATOR
		//   expressions+=simple_expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }
		
		//simple_expression
		public RuleCall getExpressionsSimple_expressionParserRuleCall_0_0() { return cExpressionsSimple_expressionParserRuleCall_0_0; }
		
		//( ( operators+=RELATIONAL_OPERATOR | operators+="in" | operators+="=" ) expressions+=simple_expression ) ?
		public Group getGroup_1() { return cGroup_1; }
		
		//( operators+=RELATIONAL_OPERATOR | operators+="in" | operators+="=" )
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//operators+=RELATIONAL_OPERATOR
		public Assignment getOperatorsAssignment_1_0_0() { return cOperatorsAssignment_1_0_0; }
		
		//RELATIONAL_OPERATOR
		public RuleCall getOperatorsRELATIONAL_OPERATORTerminalRuleCall_1_0_0_0() { return cOperatorsRELATIONAL_OPERATORTerminalRuleCall_1_0_0_0; }
		
		//operators+="in"
		public Assignment getOperatorsAssignment_1_0_1() { return cOperatorsAssignment_1_0_1; }
		
		//"in"
		public Keyword getOperatorsInKeyword_1_0_1_0() { return cOperatorsInKeyword_1_0_1_0; }
		
		//operators+="="
		public Assignment getOperatorsAssignment_1_0_2() { return cOperatorsAssignment_1_0_2; }
		
		//"="
		public Keyword getOperatorsEqualsSignKeyword_1_0_2_0() { return cOperatorsEqualsSignKeyword_1_0_2_0; }
		
		//expressions+=simple_expression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//simple_expression
		public RuleCall getExpressionsSimple_expressionParserRuleCall_1_1_0() { return cExpressionsSimple_expressionParserRuleCall_1_1_0; }
	}
	public class Simple_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.simple_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrefixOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPrefixOperatorADDITION_OPERATORTerminalRuleCall_0_0 = (RuleCall)cPrefixOperatorAssignment_0.eContents().get(0);
		private final Assignment cTermsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermsTermParserRuleCall_1_0 = (RuleCall)cTermsAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Alternatives cAlternatives_2_0_0 = (Alternatives)cGroup_2_0.eContents().get(0);
		private final Assignment cOperatorsAssignment_2_0_0_0 = (Assignment)cAlternatives_2_0_0.eContents().get(0);
		private final RuleCall cOperatorsADDITION_OPERATORTerminalRuleCall_2_0_0_0_0 = (RuleCall)cOperatorsAssignment_2_0_0_0.eContents().get(0);
		private final Assignment cOperatorsAssignment_2_0_0_1 = (Assignment)cAlternatives_2_0_0.eContents().get(1);
		private final Keyword cOperatorsOrKeyword_2_0_0_1_0 = (Keyword)cOperatorsAssignment_2_0_0_1.eContents().get(0);
		private final Assignment cTermsAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cTermsTermParserRuleCall_2_0_1_0 = (RuleCall)cTermsAssignment_2_0_1.eContents().get(0);
		private final Assignment cTermsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cTermsUnsigned_numberParserRuleCall_2_1_0 = (RuleCall)cTermsAssignment_2_1.eContents().get(0);
		
		//simple_expression hidden(WS):
		//    ( prefixOperator=ADDITION_OPERATOR ) ? terms+=term ( ( operators+=ADDITION_OPERATOR | operators+="or" ) terms+=term | terms+=unsigned_number ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//( prefixOperator=ADDITION_OPERATOR ) ? terms+=term ( ( operators+=ADDITION_OPERATOR | operators+="or" ) terms+=term | terms+=unsigned_number ) *
		public Group getGroup() { return cGroup; }
		
		//( prefixOperator=ADDITION_OPERATOR ) ?
		public Assignment getPrefixOperatorAssignment_0() { return cPrefixOperatorAssignment_0; }
		
		//ADDITION_OPERATOR
		public RuleCall getPrefixOperatorADDITION_OPERATORTerminalRuleCall_0_0() { return cPrefixOperatorADDITION_OPERATORTerminalRuleCall_0_0; }
		
		//terms+=term
		public Assignment getTermsAssignment_1() { return cTermsAssignment_1; }
		
		//term
		public RuleCall getTermsTermParserRuleCall_1_0() { return cTermsTermParserRuleCall_1_0; }
		
		//( ( operators+=ADDITION_OPERATOR | operators+="or" ) terms+=term | terms+=unsigned_number ) *
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//( operators+=ADDITION_OPERATOR | operators+="or" ) terms+=term
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//( operators+=ADDITION_OPERATOR | operators+="or" )
		public Alternatives getAlternatives_2_0_0() { return cAlternatives_2_0_0; }
		
		//operators+=ADDITION_OPERATOR
		public Assignment getOperatorsAssignment_2_0_0_0() { return cOperatorsAssignment_2_0_0_0; }
		
		//ADDITION_OPERATOR
		public RuleCall getOperatorsADDITION_OPERATORTerminalRuleCall_2_0_0_0_0() { return cOperatorsADDITION_OPERATORTerminalRuleCall_2_0_0_0_0; }
		
		//operators+="or"
		public Assignment getOperatorsAssignment_2_0_0_1() { return cOperatorsAssignment_2_0_0_1; }
		
		//"or"
		public Keyword getOperatorsOrKeyword_2_0_0_1_0() { return cOperatorsOrKeyword_2_0_0_1_0; }
		
		//terms+=term
		public Assignment getTermsAssignment_2_0_1() { return cTermsAssignment_2_0_1; }
		
		//term
		public RuleCall getTermsTermParserRuleCall_2_0_1_0() { return cTermsTermParserRuleCall_2_0_1_0; }
		
		//terms+=unsigned_number
		public Assignment getTermsAssignment_2_1() { return cTermsAssignment_2_1; }
		
		//unsigned_number
		public RuleCall getTermsUnsigned_numberParserRuleCall_2_1_0() { return cTermsUnsigned_numberParserRuleCall_2_1_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFactorsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFactorsFactorParserRuleCall_0_0 = (RuleCall)cFactorsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_0 = (Assignment)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cOperatorsMULTIPLICATION_OPERATORTerminalRuleCall_1_0_0_0 = (RuleCall)cOperatorsAssignment_1_0_0.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_1 = (Assignment)cAlternatives_1_0.eContents().get(1);
		private final Keyword cOperatorsDivKeyword_1_0_1_0 = (Keyword)cOperatorsAssignment_1_0_1.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_2 = (Assignment)cAlternatives_1_0.eContents().get(2);
		private final Keyword cOperatorsModKeyword_1_0_2_0 = (Keyword)cOperatorsAssignment_1_0_2.eContents().get(0);
		private final Assignment cOperatorsAssignment_1_0_3 = (Assignment)cAlternatives_1_0.eContents().get(3);
		private final Keyword cOperatorsAndKeyword_1_0_3_0 = (Keyword)cOperatorsAssignment_1_0_3.eContents().get(0);
		private final Assignment cFactorsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFactorsFactorParserRuleCall_1_1_0 = (RuleCall)cFactorsAssignment_1_1.eContents().get(0);
		
		//term:
		//    factors+=factor ( ( operators+=MULTIPLICATION_OPERATOR | operators+="div" | operators+="mod" | operators+="and" ) factors+=factor ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//factors+=factor ( ( operators+=MULTIPLICATION_OPERATOR | operators+="div" | operators+="mod" | operators+="and" ) factors+=factor ) *
		public Group getGroup() { return cGroup; }
		
		//factors+=factor
		public Assignment getFactorsAssignment_0() { return cFactorsAssignment_0; }
		
		//factor
		public RuleCall getFactorsFactorParserRuleCall_0_0() { return cFactorsFactorParserRuleCall_0_0; }
		
		//( ( operators+=MULTIPLICATION_OPERATOR | operators+="div" | operators+="mod" | operators+="and" ) factors+=factor ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//( operators+=MULTIPLICATION_OPERATOR | operators+="div" | operators+="mod" | operators+="and" )
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//operators+=MULTIPLICATION_OPERATOR
		public Assignment getOperatorsAssignment_1_0_0() { return cOperatorsAssignment_1_0_0; }
		
		//MULTIPLICATION_OPERATOR
		public RuleCall getOperatorsMULTIPLICATION_OPERATORTerminalRuleCall_1_0_0_0() { return cOperatorsMULTIPLICATION_OPERATORTerminalRuleCall_1_0_0_0; }
		
		//operators+="div"
		public Assignment getOperatorsAssignment_1_0_1() { return cOperatorsAssignment_1_0_1; }
		
		//"div"
		public Keyword getOperatorsDivKeyword_1_0_1_0() { return cOperatorsDivKeyword_1_0_1_0; }
		
		//operators+="mod"
		public Assignment getOperatorsAssignment_1_0_2() { return cOperatorsAssignment_1_0_2; }
		
		//"mod"
		public Keyword getOperatorsModKeyword_1_0_2_0() { return cOperatorsModKeyword_1_0_2_0; }
		
		//operators+="and"
		public Assignment getOperatorsAssignment_1_0_3() { return cOperatorsAssignment_1_0_3; }
		
		//"and"
		public Keyword getOperatorsAndKeyword_1_0_3_0() { return cOperatorsAndKeyword_1_0_3_0; }
		
		//factors+=factor
		public Assignment getFactorsAssignment_1_1() { return cFactorsAssignment_1_1; }
		
		//factor
		public RuleCall getFactorsFactorParserRuleCall_1_1_0() { return cFactorsFactorParserRuleCall_1_1_0; }
	}
	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.factor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Assignment cNumberAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNumberNumberParserRuleCall_1_0 = (RuleCall)cNumberAssignment_1.eContents().get(0);
		private final Assignment cStringAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cStringSTRINGTerminalRuleCall_2_0 = (RuleCall)cStringAssignment_2.eContents().get(0);
		private final Assignment cSetAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cSetSetParserRuleCall_3_0 = (RuleCall)cSetAssignment_3.eContents().get(0);
		private final Assignment cNilAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final Keyword cNilNilKeyword_4_0 = (Keyword)cNilAssignment_4.eContents().get(0);
		private final Assignment cBooleanAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final Keyword cBooleanTrueKeyword_5_0 = (Keyword)cBooleanAssignment_5.eContents().get(0);
		private final Assignment cBooleanAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final Keyword cBooleanFalseKeyword_6_0 = (Keyword)cBooleanAssignment_6.eContents().get(0);
		private final Assignment cFunctionAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cFunctionFunction_designatorParserRuleCall_7_0 = (RuleCall)cFunctionAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Keyword cLeftParenthesisKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cExpressionAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_8_1_0 = (RuleCall)cExpressionAssignment_8_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Keyword cNotKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cNotAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cNotFactorParserRuleCall_9_1_0 = (RuleCall)cNotAssignment_9_1.eContents().get(0);
		
		//factor:
		//    variable=variable | number=number | string=STRING | set=set | nil?="nil" | boolean="true" | boolean="false" | function=function_designator | "(" expression=expression ")" | "not" not=factor
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=variable | number=number | string=STRING | set=set | nil?="nil" | boolean="true" | boolean="false" | function=function_designator | "(" expression=expression ")" | "not" not=factor
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//variable=variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//number=number
		public Assignment getNumberAssignment_1() { return cNumberAssignment_1; }
		
		//number
		public RuleCall getNumberNumberParserRuleCall_1_0() { return cNumberNumberParserRuleCall_1_0; }
		
		//string=STRING
		public Assignment getStringAssignment_2() { return cStringAssignment_2; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_2_0() { return cStringSTRINGTerminalRuleCall_2_0; }
		
		//set=set
		public Assignment getSetAssignment_3() { return cSetAssignment_3; }
		
		//set
		public RuleCall getSetSetParserRuleCall_3_0() { return cSetSetParserRuleCall_3_0; }
		
		//nil?="nil"
		public Assignment getNilAssignment_4() { return cNilAssignment_4; }
		
		//"nil"
		public Keyword getNilNilKeyword_4_0() { return cNilNilKeyword_4_0; }
		
		//boolean="true"
		public Assignment getBooleanAssignment_5() { return cBooleanAssignment_5; }
		
		//"true"
		public Keyword getBooleanTrueKeyword_5_0() { return cBooleanTrueKeyword_5_0; }
		
		//boolean="false"
		public Assignment getBooleanAssignment_6() { return cBooleanAssignment_6; }
		
		//"false"
		public Keyword getBooleanFalseKeyword_6_0() { return cBooleanFalseKeyword_6_0; }
		
		//function=function_designator
		public Assignment getFunctionAssignment_7() { return cFunctionAssignment_7; }
		
		//function_designator
		public RuleCall getFunctionFunction_designatorParserRuleCall_7_0() { return cFunctionFunction_designatorParserRuleCall_7_0; }
		
		//"(" expression=expression ")"
		public Group getGroup_8() { return cGroup_8; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_8_0() { return cLeftParenthesisKeyword_8_0; }
		
		//expression=expression
		public Assignment getExpressionAssignment_8_1() { return cExpressionAssignment_8_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_8_1_0() { return cExpressionExpressionParserRuleCall_8_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8_2() { return cRightParenthesisKeyword_8_2; }
		
		//"not" not=factor
		public Group getGroup_9() { return cGroup_9; }
		
		//"not"
		public Keyword getNotKeyword_9_0() { return cNotKeyword_9_0; }
		
		//not=factor
		public Assignment getNotAssignment_9_1() { return cNotAssignment_9_1; }
		
		//factor
		public RuleCall getNotFactorParserRuleCall_9_1_0() { return cNotFactorParserRuleCall_9_1_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.number");
		private final Assignment cNumberAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNumberAny_numberParserRuleCall_0 = (RuleCall)cNumberAssignment.eContents().get(0);
		
		//number:
		//    number=any_number
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//number=any_number
		public Assignment getNumberAssignment() { return cNumberAssignment; }
		
		//any_number
		public RuleCall getNumberAny_numberParserRuleCall_0() { return cNumberAny_numberParserRuleCall_0; }
	}
	public class Any_numberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.any_number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnsigned_numberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSigned_numberParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//any_number:
		//    unsigned_number | signed_number
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//unsigned_number | signed_number
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//unsigned_number
		public RuleCall getUnsigned_numberParserRuleCall_0() { return cUnsigned_numberParserRuleCall_0; }
		
		//signed_number
		public RuleCall getSigned_numberParserRuleCall_1() { return cSigned_numberParserRuleCall_1; }
	}
	public class Unsigned_numberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.unsigned_number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntegerAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntegerINTEGER_NUMBERTerminalRuleCall_0_0 = (RuleCall)cIntegerAssignment_0.eContents().get(0);
		private final Assignment cRealAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cRealREAL_NUMBERTerminalRuleCall_1_0 = (RuleCall)cRealAssignment_1.eContents().get(0);
		
		//unsigned_number returns any_number:
		//    integer=INTEGER_NUMBER | real=REAL_NUMBER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//integer=INTEGER_NUMBER | real=REAL_NUMBER
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//integer=INTEGER_NUMBER
		public Assignment getIntegerAssignment_0() { return cIntegerAssignment_0; }
		
		//INTEGER_NUMBER
		public RuleCall getIntegerINTEGER_NUMBERTerminalRuleCall_0_0() { return cIntegerINTEGER_NUMBERTerminalRuleCall_0_0; }
		
		//real=REAL_NUMBER
		public Assignment getRealAssignment_1() { return cRealAssignment_1; }
		
		//REAL_NUMBER
		public RuleCall getRealREAL_NUMBERTerminalRuleCall_1_0() { return cRealREAL_NUMBERTerminalRuleCall_1_0; }
	}
	public class Signed_numberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.signed_number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntegerAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntegerSIGNED_INTEGER_NUMBERTerminalRuleCall_0_0 = (RuleCall)cIntegerAssignment_0.eContents().get(0);
		private final Assignment cRealAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cRealSIGNED_REAL_NUMBERTerminalRuleCall_1_0 = (RuleCall)cRealAssignment_1.eContents().get(0);
		
		//signed_number returns any_number:
		//    integer=SIGNED_INTEGER_NUMBER | real=SIGNED_REAL_NUMBER
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//integer=SIGNED_INTEGER_NUMBER | real=SIGNED_REAL_NUMBER
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//integer=SIGNED_INTEGER_NUMBER
		public Assignment getIntegerAssignment_0() { return cIntegerAssignment_0; }
		
		//SIGNED_INTEGER_NUMBER
		public RuleCall getIntegerSIGNED_INTEGER_NUMBERTerminalRuleCall_0_0() { return cIntegerSIGNED_INTEGER_NUMBERTerminalRuleCall_0_0; }
		
		//real=SIGNED_REAL_NUMBER
		public Assignment getRealAssignment_1() { return cRealAssignment_1; }
		
		//SIGNED_REAL_NUMBER
		public RuleCall getRealSIGNED_REAL_NUMBERTerminalRuleCall_1_0() { return cRealSIGNED_REAL_NUMBERTerminalRuleCall_1_0; }
	}
	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.set");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cBracketsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cBracketsLeftSquareBracketKeyword_0_0 = (Keyword)cBracketsAssignment_0.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsExpression_listParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Assignment cBracketsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cBracketsRightSquareBracketKeyword_2_0 = (Keyword)cBracketsAssignment_2.eContents().get(0);
		
		//set:
		//    brackets+="[" expressions=expression_list ? brackets+="]"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//brackets+="[" expressions=expression_list ? brackets+="]"
		public Group getGroup() { return cGroup; }
		
		//brackets+="["
		public Assignment getBracketsAssignment_0() { return cBracketsAssignment_0; }
		
		//"["
		public Keyword getBracketsLeftSquareBracketKeyword_0_0() { return cBracketsLeftSquareBracketKeyword_0_0; }
		
		//expressions=expression_list ?
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }
		
		//expression_list
		public RuleCall getExpressionsExpression_listParserRuleCall_1_0() { return cExpressionsExpression_listParserRuleCall_1_0; }
		
		//brackets+="]"
		public Assignment getBracketsAssignment_2() { return cBracketsAssignment_2; }
		
		//"]"
		public Keyword getBracketsRightSquareBracketKeyword_2_0() { return cBracketsRightSquareBracketKeyword_2_0; }
	}
	public class Function_designatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.function_designator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpression_listParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//function_designator:
		//    name=ID "(" expressions=expression_list ? ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID "(" expressions=expression_list ? ")"
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//expressions=expression_list ?
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }
		
		//expression_list
		public RuleCall getExpressionsExpression_listParserRuleCall_2_0() { return cExpressionsExpression_listParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Structured_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.structured_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCompoundAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCompoundCompound_statementParserRuleCall_0_0 = (RuleCall)cCompoundAssignment_0.eContents().get(0);
		private final Assignment cRepetitiveAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cRepetitiveRepetitive_statementParserRuleCall_1_0 = (RuleCall)cRepetitiveAssignment_1.eContents().get(0);
		private final Assignment cConditionalAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cConditionalConditional_statementParserRuleCall_2_0 = (RuleCall)cConditionalAssignment_2.eContents().get(0);
		private final Assignment cWithStmtAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cWithStmtWith_statementParserRuleCall_3_0 = (RuleCall)cWithStmtAssignment_3.eContents().get(0);
		
		//structured_statement:
		//    compound=compound_statement | repetitive=repetitive_statement | conditional=conditional_statement | withStmt=with_statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//compound=compound_statement | repetitive=repetitive_statement | conditional=conditional_statement | withStmt=with_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//compound=compound_statement
		public Assignment getCompoundAssignment_0() { return cCompoundAssignment_0; }
		
		//compound_statement
		public RuleCall getCompoundCompound_statementParserRuleCall_0_0() { return cCompoundCompound_statementParserRuleCall_0_0; }
		
		//repetitive=repetitive_statement
		public Assignment getRepetitiveAssignment_1() { return cRepetitiveAssignment_1; }
		
		//repetitive_statement
		public RuleCall getRepetitiveRepetitive_statementParserRuleCall_1_0() { return cRepetitiveRepetitive_statementParserRuleCall_1_0; }
		
		//conditional=conditional_statement
		public Assignment getConditionalAssignment_2() { return cConditionalAssignment_2; }
		
		//conditional_statement
		public RuleCall getConditionalConditional_statementParserRuleCall_2_0() { return cConditionalConditional_statementParserRuleCall_2_0; }
		
		//withStmt=with_statement
		public Assignment getWithStmtAssignment_3() { return cWithStmtAssignment_3; }
		
		//with_statement
		public RuleCall getWithStmtWith_statementParserRuleCall_3_0() { return cWithStmtWith_statementParserRuleCall_3_0; }
	}
	public class Compound_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.compound_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBeginKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSequenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSequenceStatement_sequenceParserRuleCall_1_0 = (RuleCall)cSequenceAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//compound_statement:
		//    "begin" sequence=statement_sequence "end"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"begin" sequence=statement_sequence "end"
		public Group getGroup() { return cGroup; }
		
		//"begin"
		public Keyword getBeginKeyword_0() { return cBeginKeyword_0; }
		
		//sequence=statement_sequence
		public Assignment getSequenceAssignment_1() { return cSequenceAssignment_1; }
		
		//statement_sequence
		public RuleCall getSequenceStatement_sequenceParserRuleCall_1_0() { return cSequenceStatement_sequenceParserRuleCall_1_0; }
		
		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}
	public class Repetitive_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.repetitive_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cWhileStmtAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cWhileStmtWhile_statementParserRuleCall_0_0 = (RuleCall)cWhileStmtAssignment_0.eContents().get(0);
		private final Assignment cRepeatStmtAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cRepeatStmtRepeat_statementParserRuleCall_1_0 = (RuleCall)cRepeatStmtAssignment_1.eContents().get(0);
		private final Assignment cForStmtAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cForStmtFor_statementParserRuleCall_2_0 = (RuleCall)cForStmtAssignment_2.eContents().get(0);
		
		//repetitive_statement:
		//    whileStmt=while_statement | repeatStmt=repeat_statement | forStmt=for_statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//whileStmt=while_statement | repeatStmt=repeat_statement | forStmt=for_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//whileStmt=while_statement
		public Assignment getWhileStmtAssignment_0() { return cWhileStmtAssignment_0; }
		
		//while_statement
		public RuleCall getWhileStmtWhile_statementParserRuleCall_0_0() { return cWhileStmtWhile_statementParserRuleCall_0_0; }
		
		//repeatStmt=repeat_statement
		public Assignment getRepeatStmtAssignment_1() { return cRepeatStmtAssignment_1; }
		
		//repeat_statement
		public RuleCall getRepeatStmtRepeat_statementParserRuleCall_1_0() { return cRepeatStmtRepeat_statementParserRuleCall_1_0; }
		
		//forStmt=for_statement
		public Assignment getForStmtAssignment_2() { return cForStmtAssignment_2; }
		
		//for_statement
		public RuleCall getForStmtFor_statementParserRuleCall_2_0() { return cForStmtFor_statementParserRuleCall_2_0; }
	}
	public class While_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.while_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		
		//while_statement:
		//    "while" expression=expression "do" statement=statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"while" expression=expression "do" statement=statement
		public Group getGroup() { return cGroup; }
		
		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }
		
		//expression=expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }
		
		//statement=statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }
		
		//statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }
	}
	public class Repeat_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.repeat_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRepeatKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSequenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSequenceStatement_sequenceParserRuleCall_1_0 = (RuleCall)cSequenceAssignment_1.eContents().get(0);
		private final Keyword cUntilKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//repeat_statement:
		//    "repeat" sequence=statement_sequence "until" expression=expression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"repeat" sequence=statement_sequence "until" expression=expression
		public Group getGroup() { return cGroup; }
		
		//"repeat"
		public Keyword getRepeatKeyword_0() { return cRepeatKeyword_0; }
		
		//sequence=statement_sequence
		public Assignment getSequenceAssignment_1() { return cSequenceAssignment_1; }
		
		//statement_sequence
		public RuleCall getSequenceStatement_sequenceParserRuleCall_1_0() { return cSequenceStatement_sequenceParserRuleCall_1_0; }
		
		//"until"
		public Keyword getUntilKeyword_2() { return cUntilKeyword_2; }
		
		//expression=expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}
	public class For_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.for_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAssignmentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAssignmentAssignment_statementParserRuleCall_1_0 = (RuleCall)cAssignmentAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cToKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cDowntoKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cDoKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cStatementAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementStatementParserRuleCall_5_0 = (RuleCall)cStatementAssignment_5.eContents().get(0);
		
		//for_statement:
		//    "for" assignment=assignment_statement ( "to" | "downto" ) expression=expression "do" statement=statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"for" assignment=assignment_statement ( "to" | "downto" ) expression=expression "do" statement=statement
		public Group getGroup() { return cGroup; }
		
		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//assignment=assignment_statement
		public Assignment getAssignmentAssignment_1() { return cAssignmentAssignment_1; }
		
		//assignment_statement
		public RuleCall getAssignmentAssignment_statementParserRuleCall_1_0() { return cAssignmentAssignment_statementParserRuleCall_1_0; }
		
		//( "to" | "downto" )
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//"to"
		public Keyword getToKeyword_2_0() { return cToKeyword_2_0; }
		
		//"downto"
		public Keyword getDowntoKeyword_2_1() { return cDowntoKeyword_2_1; }
		
		//expression=expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
		
		//"do"
		public Keyword getDoKeyword_4() { return cDoKeyword_4; }
		
		//statement=statement
		public Assignment getStatementAssignment_5() { return cStatementAssignment_5; }
		
		//statement
		public RuleCall getStatementStatementParserRuleCall_5_0() { return cStatementStatementParserRuleCall_5_0; }
	}
	public class Conditional_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.conditional_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIfStmtAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIfStmtIf_statementParserRuleCall_0_0 = (RuleCall)cIfStmtAssignment_0.eContents().get(0);
		private final Assignment cCaseStmtAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cCaseStmtCase_statementParserRuleCall_1_0 = (RuleCall)cCaseStmtAssignment_1.eContents().get(0);
		
		//conditional_statement:
		//    ifStmt=if_statement | caseStmt=case_statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ifStmt=if_statement | caseStmt=case_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ifStmt=if_statement
		public Assignment getIfStmtAssignment_0() { return cIfStmtAssignment_0; }
		
		//if_statement
		public RuleCall getIfStmtIf_statementParserRuleCall_0_0() { return cIfStmtIf_statementParserRuleCall_0_0; }
		
		//caseStmt=case_statement
		public Assignment getCaseStmtAssignment_1() { return cCaseStmtAssignment_1; }
		
		//case_statement
		public RuleCall getCaseStmtCase_statementParserRuleCall_1_0() { return cCaseStmtCase_statementParserRuleCall_1_0; }
	}
	public class If_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.if_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIfStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIfStatementStatementParserRuleCall_3_0 = (RuleCall)cIfStatementAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cElseKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cElseStatementAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cElseStatementStatementParserRuleCall_4_1_0 = (RuleCall)cElseStatementAssignment_4_1.eContents().get(0);
		
		//if_statement:
		//    "if" expression=expression "then" ifStatement=statement ( "else" elseStatement=statement )    ?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"if" expression=expression "then" ifStatement=statement ( "else" elseStatement=statement )	?
		public Group getGroup() { return cGroup; }
		
		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//expression=expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
		
		//ifStatement=statement
		public Assignment getIfStatementAssignment_3() { return cIfStatementAssignment_3; }
		
		//statement
		public RuleCall getIfStatementStatementParserRuleCall_3_0() { return cIfStatementStatementParserRuleCall_3_0; }
		
		//( "else" elseStatement=statement )	?
		public Group getGroup_4() { return cGroup_4; }
		
		//"else"
		public Keyword getElseKeyword_4_0() { return cElseKeyword_4_0; }
		
		//elseStatement=statement
		public Assignment getElseStatementAssignment_4_1() { return cElseStatementAssignment_4_1; }
		
		//statement
		public RuleCall getElseStatementStatementParserRuleCall_4_1_0() { return cElseStatementStatementParserRuleCall_4_1_0; }
	}
	public class Case_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.case_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCasesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasesCase_limbParserRuleCall_3_0 = (RuleCall)cCasesAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cCasesAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCasesCase_limbParserRuleCall_4_1_0 = (RuleCall)cCasesAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//case_statement:
		//    "case" expression=expression "of" cases+=case_limb ( ";" cases+=case_limb ) * ( ";" ) ? "end"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"case" expression=expression "of" cases+=case_limb ( ";" cases+=case_limb ) * ( ";" ) ? "end"
		public Group getGroup() { return cGroup; }
		
		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//expression=expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
		
		//cases+=case_limb
		public Assignment getCasesAssignment_3() { return cCasesAssignment_3; }
		
		//case_limb
		public RuleCall getCasesCase_limbParserRuleCall_3_0() { return cCasesCase_limbParserRuleCall_3_0; }
		
		//( ";" cases+=case_limb ) *
		public Group getGroup_4() { return cGroup_4; }
		
		//";"
		public Keyword getSemicolonKeyword_4_0() { return cSemicolonKeyword_4_0; }
		
		//cases+=case_limb
		public Assignment getCasesAssignment_4_1() { return cCasesAssignment_4_1; }
		
		//case_limb
		public RuleCall getCasesCase_limbParserRuleCall_4_1_0() { return cCasesCase_limbParserRuleCall_4_1_0; }
		
		//( ";" ) ?
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
		
		//"end"
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class Case_limbElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.case_limb");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesCase_label_listParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		
		//case_limb:
		//    cases=case_label_list ":" statement=statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//cases=case_label_list ":" statement=statement
		public Group getGroup() { return cGroup; }
		
		//cases=case_label_list
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }
		
		//case_label_list
		public RuleCall getCasesCase_label_listParserRuleCall_0_0() { return cCasesCase_label_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//statement=statement
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }
		
		//statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }
	}
	public class Case_label_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.case_label_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantsConstantParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConstantsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConstantsConstantParserRuleCall_1_1_0 = (RuleCall)cConstantsAssignment_1_1.eContents().get(0);
		
		//case_label_list:
		//    constants+=constant ( "," constants+=constant ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//constants+=constant ( "," constants+=constant ) *
		public Group getGroup() { return cGroup; }
		
		//constants+=constant
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }
		
		//constant
		public RuleCall getConstantsConstantParserRuleCall_0_0() { return cConstantsConstantParserRuleCall_0_0; }
		
		//( "," constants+=constant ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//constants+=constant
		public Assignment getConstantsAssignment_1_1() { return cConstantsAssignment_1_1; }
		
		//constant
		public RuleCall getConstantsConstantParserRuleCall_1_1_0() { return cConstantsConstantParserRuleCall_1_1_0; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cOpteratorAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cOpteratorADDITION_OPERATORTerminalRuleCall_0_0_0 = (RuleCall)cOpteratorAssignment_0_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_1_0 = (Assignment)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_1_0_0 = (RuleCall)cNameAssignment_0_1_0.eContents().get(0);
		private final Assignment cNumberAssignment_0_1_1 = (Assignment)cAlternatives_0_1.eContents().get(1);
		private final RuleCall cNumberNumberParserRuleCall_0_1_1_0 = (RuleCall)cNumberAssignment_0_1_1.eContents().get(0);
		private final Assignment cStringAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStringSTRINGTerminalRuleCall_1_0 = (RuleCall)cStringAssignment_1.eContents().get(0);
		private final Assignment cBoolLiteralAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cBoolLiteralTrueKeyword_2_0 = (Keyword)cBoolLiteralAssignment_2.eContents().get(0);
		private final Assignment cBoolLiteralAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final Keyword cBoolLiteralFalseKeyword_3_0 = (Keyword)cBoolLiteralAssignment_3.eContents().get(0);
		private final Assignment cNilAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final Keyword cNilNilKeyword_4_0 = (Keyword)cNilAssignment_4.eContents().get(0);
		
		//constant:
		//    opterator=ADDITION_OPERATOR ? ( name=ID | number=number ) | string=STRING | boolLiteral="true" | boolLiteral="false" | nil="nil"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//opterator=ADDITION_OPERATOR ? ( name=ID | number=number ) | string=STRING | boolLiteral="true" | boolLiteral="false" | nil="nil"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//opterator=ADDITION_OPERATOR ? ( name=ID | number=number )
		public Group getGroup_0() { return cGroup_0; }
		
		//opterator=ADDITION_OPERATOR ?
		public Assignment getOpteratorAssignment_0_0() { return cOpteratorAssignment_0_0; }
		
		//ADDITION_OPERATOR
		public RuleCall getOpteratorADDITION_OPERATORTerminalRuleCall_0_0_0() { return cOpteratorADDITION_OPERATORTerminalRuleCall_0_0_0; }
		
		//( name=ID | number=number )
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_0_1_0() { return cNameAssignment_0_1_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_0_0() { return cNameIDTerminalRuleCall_0_1_0_0; }
		
		//number=number
		public Assignment getNumberAssignment_0_1_1() { return cNumberAssignment_0_1_1; }
		
		//number
		public RuleCall getNumberNumberParserRuleCall_0_1_1_0() { return cNumberNumberParserRuleCall_0_1_1_0; }
		
		//string=STRING
		public Assignment getStringAssignment_1() { return cStringAssignment_1; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_1_0() { return cStringSTRINGTerminalRuleCall_1_0; }
		
		//boolLiteral="true"
		public Assignment getBoolLiteralAssignment_2() { return cBoolLiteralAssignment_2; }
		
		//"true"
		public Keyword getBoolLiteralTrueKeyword_2_0() { return cBoolLiteralTrueKeyword_2_0; }
		
		//boolLiteral="false"
		public Assignment getBoolLiteralAssignment_3() { return cBoolLiteralAssignment_3; }
		
		//"false"
		public Keyword getBoolLiteralFalseKeyword_3_0() { return cBoolLiteralFalseKeyword_3_0; }
		
		//nil="nil"
		public Assignment getNilAssignment_4() { return cNilAssignment_4; }
		
		//"nil"
		public Keyword getNilNilKeyword_4_0() { return cNilNilKeyword_4_0; }
	}
	public class With_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.with_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWithKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariablesVariableParserRuleCall_1_0 = (RuleCall)cVariablesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariablesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariablesVariableParserRuleCall_2_1_0 = (RuleCall)cVariablesAssignment_2_1.eContents().get(0);
		private final Keyword cDoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		
		//with_statement:
		//    "with" variables+=variable ( "," variables+=variable ) * "do" statement=statement
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"with" variables+=variable ( "," variables+=variable ) * "do" statement=statement
		public Group getGroup() { return cGroup; }
		
		//"with"
		public Keyword getWithKeyword_0() { return cWithKeyword_0; }
		
		//variables+=variable
		public Assignment getVariablesAssignment_1() { return cVariablesAssignment_1; }
		
		//variable
		public RuleCall getVariablesVariableParserRuleCall_1_0() { return cVariablesVariableParserRuleCall_1_0; }
		
		//( "," variables+=variable ) *
		public Group getGroup_2() { return cGroup_2; }
		
		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//variables+=variable
		public Assignment getVariablesAssignment_2_1() { return cVariablesAssignment_2_1; }
		
		//variable
		public RuleCall getVariablesVariableParserRuleCall_2_1_0() { return cVariablesVariableParserRuleCall_2_1_0; }
		
		//"do"
		public Keyword getDoKeyword_3() { return cDoKeyword_3; }
		
		//statement=statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }
		
		//statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }
	}
	public class Goto_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.goto_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGotoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLabelLabelParserRuleCall_1_0 = (RuleCall)cLabelAssignment_1.eContents().get(0);
		
		//goto_statement:
		//    "goto" label=label
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"goto" label=label
		public Group getGroup() { return cGroup; }
		
		//"goto"
		public Keyword getGotoKeyword_0() { return cGotoKeyword_0; }
		
		//label=label
		public Assignment getLabelAssignment_1() { return cLabelAssignment_1; }
		
		//label
		public RuleCall getLabelLabelParserRuleCall_1_0() { return cLabelLabelParserRuleCall_1_0; }
	}
	public class Label_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.label_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLabelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLabelsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLabelsLabelParserRuleCall_1_0 = (RuleCall)cLabelsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLabelsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLabelsLabelParserRuleCall_2_1_0 = (RuleCall)cLabelsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//label_declaration_part:
		//    "label" labels+=label ( "," labels+=label ) * ";"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"label" labels+=label ( "," labels+=label ) * ";"
		public Group getGroup() { return cGroup; }
		
		//"label"
		public Keyword getLabelKeyword_0() { return cLabelKeyword_0; }
		
		//labels+=label
		public Assignment getLabelsAssignment_1() { return cLabelsAssignment_1; }
		
		//label
		public RuleCall getLabelsLabelParserRuleCall_1_0() { return cLabelsLabelParserRuleCall_1_0; }
		
		//( "," labels+=label ) *
		public Group getGroup_2() { return cGroup_2; }
		
		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//labels+=label
		public Assignment getLabelsAssignment_2_1() { return cLabelsAssignment_2_1; }
		
		//label
		public RuleCall getLabelsLabelParserRuleCall_2_1_0() { return cLabelsLabelParserRuleCall_2_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class Constant_definition_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.constant_definition_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cConstsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cConstsConstant_definitionParserRuleCall_1_0_0 = (RuleCall)cConstsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//constant_definition_part:
		//    "const" ( consts+=constant_definition ";" ) +
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"const" ( consts+=constant_definition ";" ) +
		public Group getGroup() { return cGroup; }
		
		//"const"
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }
		
		//( consts+=constant_definition ";" ) +
		public Group getGroup_1() { return cGroup_1; }
		
		//consts+=constant_definition
		public Assignment getConstsAssignment_1_0() { return cConstsAssignment_1_0; }
		
		//constant_definition
		public RuleCall getConstsConstant_definitionParserRuleCall_1_0_0() { return cConstsConstant_definitionParserRuleCall_1_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class Constant_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.constant_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConstAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstConstantParserRuleCall_2_0 = (RuleCall)cConstAssignment_2.eContents().get(0);
		
		//constant_definition:
		//    name=ID "=" const=constant
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID "=" const=constant
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//const=constant
		public Assignment getConstAssignment_2() { return cConstAssignment_2; }
		
		//constant
		public RuleCall getConstConstantParserRuleCall_2_0() { return cConstConstantParserRuleCall_2_0; }
	}
	public class Type_definition_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.type_definition_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypesType_definitionParserRuleCall_1_0_0 = (RuleCall)cTypesAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//type_definition_part:
		//    "type" ( types+=type_definition ";" ) +
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"type" ( types+=type_definition ";" ) +
		public Group getGroup() { return cGroup; }
		
		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }
		
		//( types+=type_definition ";" ) +
		public Group getGroup_1() { return cGroup_1; }
		
		//types+=type_definition
		public Assignment getTypesAssignment_1_0() { return cTypesAssignment_1_0; }
		
		//type_definition
		public RuleCall getTypesType_definitionParserRuleCall_1_0_0() { return cTypesType_definitionParserRuleCall_1_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class Type_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.type_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//type_definition:
		//    name=ID "=" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID "=" type=type
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cSimpleAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleSimple_typeParserRuleCall_0_0 = (RuleCall)cSimpleAssignment_0.eContents().get(0);
		private final Assignment cStructuredAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStructuredStructured_typeParserRuleCall_1_0 = (RuleCall)cStructuredAssignment_1.eContents().get(0);
		private final Assignment cPointerAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cPointerPointer_typeParserRuleCall_2_0 = (RuleCall)cPointerAssignment_2.eContents().get(0);
		
		//type: //TODO: REMOVED ID
		//    simple=simple_type | structured=structured_type | pointer=pointer_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: REMOVED ID
		//   simple=simple_type | structured=structured_type | pointer=pointer_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////TODO: REMOVED ID
		//   simple=simple_type
		public Assignment getSimpleAssignment_0() { return cSimpleAssignment_0; }
		
		//simple_type
		public RuleCall getSimpleSimple_typeParserRuleCall_0_0() { return cSimpleSimple_typeParserRuleCall_0_0; }
		
		//structured=structured_type
		public Assignment getStructuredAssignment_1() { return cStructuredAssignment_1; }
		
		//structured_type
		public RuleCall getStructuredStructured_typeParserRuleCall_1_0() { return cStructuredStructured_typeParserRuleCall_1_0; }
		
		//pointer=pointer_type
		public Assignment getPointerAssignment_2() { return cPointerAssignment_2; }
		
		//pointer_type
		public RuleCall getPointerPointer_typeParserRuleCall_2_0() { return cPointerPointer_typeParserRuleCall_2_0; }
	}
	public class Simple_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.simple_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cSubrangeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cSubrangeSubrange_typeParserRuleCall_0_0 = (RuleCall)cSubrangeAssignment_0.eContents().get(0);
		private final Assignment cEnumeratedAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cEnumeratedEnumerated_typeParserRuleCall_1_0 = (RuleCall)cEnumeratedAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//simple_type: //TODO: ADDED ID
		//    subrange=subrange_type | enumerated=enumerated_type | name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: ADDED ID
		//   subrange=subrange_type | enumerated=enumerated_type | name=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////TODO: ADDED ID
		//   subrange=subrange_type
		public Assignment getSubrangeAssignment_0() { return cSubrangeAssignment_0; }
		
		//subrange_type
		public RuleCall getSubrangeSubrange_typeParserRuleCall_0_0() { return cSubrangeSubrange_typeParserRuleCall_0_0; }
		
		//enumerated=enumerated_type
		public Assignment getEnumeratedAssignment_1() { return cEnumeratedAssignment_1; }
		
		//enumerated_type
		public RuleCall getEnumeratedEnumerated_typeParserRuleCall_1_0() { return cEnumeratedEnumerated_typeParserRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}
	public class Subrange_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.subrange_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cInitialConstAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cInitialConstConstantParserRuleCall_0_0_0 = (RuleCall)cInitialConstAssignment_0_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cFinalConstAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cFinalConstConstantParserRuleCall_0_2_0 = (RuleCall)cFinalConstAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cSubrangeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cSubrangeNUMERIC_SUBRANGETerminalRuleCall_1_0_0 = (RuleCall)cSubrangeAssignment_1_0.eContents().get(0);
		private final Assignment cConstAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConstConstantParserRuleCall_1_1_0 = (RuleCall)cConstAssignment_1_1.eContents().get(0);
		
		//subrange_type hidden(WS): //TODO: ADDED HIDDEN(WS) TO REMOVE BLANK SPACE
		//     initialConst=constant ".." finalConst=constant | subrange=NUMERIC_SUBRANGE const=constant
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: ADDED HIDDEN(WS) TO REMOVE BLANK SPACE
		//    initialConst=constant ".." finalConst=constant | subrange=NUMERIC_SUBRANGE const=constant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////TODO: ADDED HIDDEN(WS) TO REMOVE BLANK SPACE
		//    initialConst=constant ".." finalConst=constant
		public Group getGroup_0() { return cGroup_0; }
		
		////TODO: ADDED HIDDEN(WS) TO REMOVE BLANK SPACE
		//    initialConst=constant
		public Assignment getInitialConstAssignment_0_0() { return cInitialConstAssignment_0_0; }
		
		//constant
		public RuleCall getInitialConstConstantParserRuleCall_0_0_0() { return cInitialConstConstantParserRuleCall_0_0_0; }
		
		//".."
		public Keyword getFullStopFullStopKeyword_0_1() { return cFullStopFullStopKeyword_0_1; }
		
		//finalConst=constant
		public Assignment getFinalConstAssignment_0_2() { return cFinalConstAssignment_0_2; }
		
		//constant
		public RuleCall getFinalConstConstantParserRuleCall_0_2_0() { return cFinalConstConstantParserRuleCall_0_2_0; }
		
		//subrange=NUMERIC_SUBRANGE const=constant
		public Group getGroup_1() { return cGroup_1; }
		
		//subrange=NUMERIC_SUBRANGE
		public Assignment getSubrangeAssignment_1_0() { return cSubrangeAssignment_1_0; }
		
		//NUMERIC_SUBRANGE
		public RuleCall getSubrangeNUMERIC_SUBRANGETerminalRuleCall_1_0_0() { return cSubrangeNUMERIC_SUBRANGETerminalRuleCall_1_0_0; }
		
		//const=constant
		public Assignment getConstAssignment_1_1() { return cConstAssignment_1_1; }
		
		//constant
		public RuleCall getConstConstantParserRuleCall_1_1_0() { return cConstConstantParserRuleCall_1_1_0; }
	}
	public class Enumerated_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.enumerated_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifiersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifiersIdentifier_listParserRuleCall_1_0 = (RuleCall)cIdentifiersAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//enumerated_type:
		//    "(" identifiers=identifier_list ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"(" identifiers=identifier_list ")"
		public Group getGroup() { return cGroup; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//identifiers=identifier_list
		public Assignment getIdentifiersAssignment_1() { return cIdentifiersAssignment_1; }
		
		//identifier_list
		public RuleCall getIdentifiersIdentifier_listParserRuleCall_1_0() { return cIdentifiersIdentifier_listParserRuleCall_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class Structured_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.structured_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPackedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cPackedPackedKeyword_0_0 = (Keyword)cPackedAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeUnpacked_structured_typeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		//structured_type:
		//    ( packed?="packed" ) ? type=unpacked_structured_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//( packed?="packed" ) ? type=unpacked_structured_type
		public Group getGroup() { return cGroup; }
		
		//( packed?="packed" ) ?
		public Assignment getPackedAssignment_0() { return cPackedAssignment_0; }
		
		//"packed"
		public Keyword getPackedPackedKeyword_0_0() { return cPackedPackedKeyword_0_0; }
		
		//type=unpacked_structured_type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//unpacked_structured_type
		public RuleCall getTypeUnpacked_structured_typeParserRuleCall_1_0() { return cTypeUnpacked_structured_typeParserRuleCall_1_0; }
	}
	public class Unpacked_structured_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.unpacked_structured_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cArrayAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cArrayArray_typeParserRuleCall_0_0 = (RuleCall)cArrayAssignment_0.eContents().get(0);
		private final Assignment cDynamicAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDynamicDynamic_array_typeParserRuleCall_1_0 = (RuleCall)cDynamicAssignment_1.eContents().get(0);
		private final Assignment cRecordAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cRecordRecord_typeParserRuleCall_2_0 = (RuleCall)cRecordAssignment_2.eContents().get(0);
		private final Assignment cSetAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cSetSet_typeParserRuleCall_3_0 = (RuleCall)cSetAssignment_3.eContents().get(0);
		private final Assignment cFileAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cFileFile_typeParserRuleCall_4_0 = (RuleCall)cFileAssignment_4.eContents().get(0);
		
		//unpacked_structured_type: //TODO: ADDED DYNAMIC_ARRAY_TYPE
		//    array=array_type | dynamic=dynamic_array_type | record=record_type | set=set_type | file=file_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: ADDED DYNAMIC_ARRAY_TYPE
		//   array=array_type | dynamic=dynamic_array_type | record=record_type | set=set_type | file=file_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////TODO: ADDED DYNAMIC_ARRAY_TYPE
		//   array=array_type
		public Assignment getArrayAssignment_0() { return cArrayAssignment_0; }
		
		//array_type
		public RuleCall getArrayArray_typeParserRuleCall_0_0() { return cArrayArray_typeParserRuleCall_0_0; }
		
		//dynamic=dynamic_array_type
		public Assignment getDynamicAssignment_1() { return cDynamicAssignment_1; }
		
		//dynamic_array_type
		public RuleCall getDynamicDynamic_array_typeParserRuleCall_1_0() { return cDynamicDynamic_array_typeParserRuleCall_1_0; }
		
		//record=record_type
		public Assignment getRecordAssignment_2() { return cRecordAssignment_2; }
		
		//record_type
		public RuleCall getRecordRecord_typeParserRuleCall_2_0() { return cRecordRecord_typeParserRuleCall_2_0; }
		
		//set=set_type
		public Assignment getSetAssignment_3() { return cSetAssignment_3; }
		
		//set_type
		public RuleCall getSetSet_typeParserRuleCall_3_0() { return cSetSet_typeParserRuleCall_3_0; }
		
		//file=file_type
		public Assignment getFileAssignment_4() { return cFileAssignment_4; }
		
		//file_type
		public RuleCall getFileFile_typeParserRuleCall_4_0() { return cFileFile_typeParserRuleCall_4_0; }
	}
	public class Array_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.array_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIndexesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIndexesIndex_typeParserRuleCall_2_0 = (RuleCall)cIndexesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cIndexesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cIndexesIndex_typeParserRuleCall_3_1_0 = (RuleCall)cIndexesAssignment_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cOfKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTypeTypeParserRuleCall_6_0 = (RuleCall)cTypeAssignment_6.eContents().get(0);
		
		//array_type:
		//    "array" "[" indexes+=index_type ( "," indexes+=index_type ) * "]" "of" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"array" "[" indexes+=index_type ( "," indexes+=index_type ) * "]" "of" type=type
		public Group getGroup() { return cGroup; }
		
		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//indexes+=index_type
		public Assignment getIndexesAssignment_2() { return cIndexesAssignment_2; }
		
		//index_type
		public RuleCall getIndexesIndex_typeParserRuleCall_2_0() { return cIndexesIndex_typeParserRuleCall_2_0; }
		
		//( "," indexes+=index_type ) *
		public Group getGroup_3() { return cGroup_3; }
		
		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//indexes+=index_type
		public Assignment getIndexesAssignment_3_1() { return cIndexesAssignment_3_1; }
		
		//index_type
		public RuleCall getIndexesIndex_typeParserRuleCall_3_1_0() { return cIndexesIndex_typeParserRuleCall_3_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//"of"
		public Keyword getOfKeyword_5() { return cOfKeyword_5; }
		
		//type=type
		public Assignment getTypeAssignment_6() { return cTypeAssignment_6; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_6_0() { return cTypeTypeParserRuleCall_6_0; }
	}
	public class Dynamic_array_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.dynamic_array_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//dynamic_array_type:
		//    "array" "of" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"array" "of" type=type
		public Group getGroup() { return cGroup; }
		
		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }
		
		//"of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class Index_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.index_type");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypeSimple_typeParserRuleCall_0 = (RuleCall)cTypeAssignment.eContents().get(0);
		
		//index_type:
		//    type=simple_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//type=simple_type
		public Assignment getTypeAssignment() { return cTypeAssignment; }
		
		//simple_type
		public RuleCall getTypeSimple_typeParserRuleCall_0() { return cTypeSimple_typeParserRuleCall_0; }
	}
	public class Record_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.record_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRecordKeywordAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cRecordKeywordRecordKeyword_0_0 = (Keyword)cRecordKeywordAssignment_0.eContents().get(0);
		private final Assignment cFieldsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldsField_listParserRuleCall_1_0 = (RuleCall)cFieldsAssignment_1.eContents().get(0);
		private final Assignment cEndKeywordAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEndKeywordEndKeyword_2_0 = (Keyword)cEndKeywordAssignment_2.eContents().get(0);
		
		//record_type:
		//    recordKeyword="record" fields=field_list? endKeyword="end"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//recordKeyword="record" fields=field_list? endKeyword="end"
		public Group getGroup() { return cGroup; }
		
		//recordKeyword="record"
		public Assignment getRecordKeywordAssignment_0() { return cRecordKeywordAssignment_0; }
		
		//"record"
		public Keyword getRecordKeywordRecordKeyword_0_0() { return cRecordKeywordRecordKeyword_0_0; }
		
		//fields=field_list?
		public Assignment getFieldsAssignment_1() { return cFieldsAssignment_1; }
		
		//field_list
		public RuleCall getFieldsField_listParserRuleCall_1_0() { return cFieldsField_listParserRuleCall_1_0; }
		
		//endKeyword="end"
		public Assignment getEndKeywordAssignment_2() { return cEndKeywordAssignment_2; }
		
		//"end"
		public Keyword getEndKeywordEndKeyword_2_0() { return cEndKeywordEndKeyword_2_0; }
	}
	public class Field_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.field_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Assignment cFixedAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cFixedFixed_partParserRuleCall_0_0_0_0 = (RuleCall)cFixedAssignment_0_0_0.eContents().get(0);
		private final Group cGroup_0_0_1 = (Group)cGroup_0_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_0_0_1_0 = (Keyword)cGroup_0_0_1.eContents().get(0);
		private final Assignment cVariantsAssignment_0_0_1_1 = (Assignment)cGroup_0_0_1.eContents().get(1);
		private final RuleCall cVariantsVariant_partParserRuleCall_0_0_1_1_0 = (RuleCall)cVariantsAssignment_0_0_1_1.eContents().get(0);
		private final Assignment cVariantsAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cVariantsVariant_partParserRuleCall_0_1_0 = (RuleCall)cVariantsAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//field_list:
		//    ( fixed=fixed_part ( ";" variants+=variant_part ) ? | variants+=variant_part ) ( ";" ) ?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//( fixed=fixed_part ( ";" variants+=variant_part ) ? | variants+=variant_part ) ( ";" ) ?
		public Group getGroup() { return cGroup; }
		
		//( fixed=fixed_part ( ";" variants+=variant_part ) ? | variants+=variant_part )
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//fixed=fixed_part ( ";" variants+=variant_part ) ?
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//fixed=fixed_part
		public Assignment getFixedAssignment_0_0_0() { return cFixedAssignment_0_0_0; }
		
		//fixed_part
		public RuleCall getFixedFixed_partParserRuleCall_0_0_0_0() { return cFixedFixed_partParserRuleCall_0_0_0_0; }
		
		//( ";" variants+=variant_part ) ?
		public Group getGroup_0_0_1() { return cGroup_0_0_1; }
		
		//";"
		public Keyword getSemicolonKeyword_0_0_1_0() { return cSemicolonKeyword_0_0_1_0; }
		
		//variants+=variant_part
		public Assignment getVariantsAssignment_0_0_1_1() { return cVariantsAssignment_0_0_1_1; }
		
		//variant_part
		public RuleCall getVariantsVariant_partParserRuleCall_0_0_1_1_0() { return cVariantsVariant_partParserRuleCall_0_0_1_1_0; }
		
		//variants+=variant_part
		public Assignment getVariantsAssignment_0_1() { return cVariantsAssignment_0_1; }
		
		//variant_part
		public RuleCall getVariantsVariant_partParserRuleCall_0_1_0() { return cVariantsVariant_partParserRuleCall_0_1_0; }
		
		//( ";" ) ?
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class Fixed_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.fixed_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSectionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSectionsRecord_sectionParserRuleCall_0_0 = (RuleCall)cSectionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSectionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSectionsRecord_sectionParserRuleCall_1_1_0 = (RuleCall)cSectionsAssignment_1_1.eContents().get(0);
		
		//fixed_part:
		//    sections+=record_section ( ";" sections+=record_section ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//sections+=record_section ( ";" sections+=record_section ) *
		public Group getGroup() { return cGroup; }
		
		//sections+=record_section
		public Assignment getSectionsAssignment_0() { return cSectionsAssignment_0; }
		
		//record_section
		public RuleCall getSectionsRecord_sectionParserRuleCall_0_0() { return cSectionsRecord_sectionParserRuleCall_0_0; }
		
		//( ";" sections+=record_section ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }
		
		//sections+=record_section
		public Assignment getSectionsAssignment_1_1() { return cSectionsAssignment_1_1; }
		
		//record_section
		public RuleCall getSectionsRecord_sectionParserRuleCall_1_1_0() { return cSectionsRecord_sectionParserRuleCall_1_1_0; }
	}
	public class Variable_identifier_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variable_identifier_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_1_0 = (RuleCall)cNamesAssignment_1_1.eContents().get(0);
		
		//variable_identifier_list:
		//    names+=ID ( "," names+=ID ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID ( "," names+=ID ) *
		public Group getGroup() { return cGroup; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//( "," names+=ID ) *
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_1_1() { return cNamesAssignment_1_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_1_0() { return cNamesIDTerminalRuleCall_1_1_0; }
	}
	public class Variable_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variable_section");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdentifiersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdentifiersVariable_identifier_listParserRuleCall_0_0 = (RuleCall)cIdentifiersAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//variable_section:
		//    identifiers=variable_identifier_list ":" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//identifiers=variable_identifier_list ":" type=type
		public Group getGroup() { return cGroup; }
		
		//identifiers=variable_identifier_list
		public Assignment getIdentifiersAssignment_0() { return cIdentifiersAssignment_0; }
		
		//variable_identifier_list
		public RuleCall getIdentifiersVariable_identifier_listParserRuleCall_0_0() { return cIdentifiersVariable_identifier_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class Record_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.record_section");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdentifiersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdentifiersIdentifier_listParserRuleCall_0_0 = (RuleCall)cIdentifiersAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//record_section:
		//    identifiers=identifier_list ":" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//identifiers=identifier_list ":" type=type
		public Group getGroup() { return cGroup; }
		
		//identifiers=identifier_list
		public Assignment getIdentifiersAssignment_0() { return cIdentifiersAssignment_0; }
		
		//identifier_list
		public RuleCall getIdentifiersIdentifier_listParserRuleCall_0_0() { return cIdentifiersIdentifier_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class Variant_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variant_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTagAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTagTag_fieldParserRuleCall_1_0 = (RuleCall)cTagAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cOfKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVariantsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVariantsVariantParserRuleCall_4_0 = (RuleCall)cVariantsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVariantsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVariantsVariantParserRuleCall_5_1_0 = (RuleCall)cVariantsAssignment_5_1.eContents().get(0);
		
		//variant_part:
		//    "case" tag=tag_field? name=ID "of" variants+=variant ( ";" variants+=variant ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"case" tag=tag_field? name=ID "of" variants+=variant ( ";" variants+=variant ) *
		public Group getGroup() { return cGroup; }
		
		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//tag=tag_field?
		public Assignment getTagAssignment_1() { return cTagAssignment_1; }
		
		//tag_field
		public RuleCall getTagTag_fieldParserRuleCall_1_0() { return cTagTag_fieldParserRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//"of"
		public Keyword getOfKeyword_3() { return cOfKeyword_3; }
		
		//variants+=variant
		public Assignment getVariantsAssignment_4() { return cVariantsAssignment_4; }
		
		//variant
		public RuleCall getVariantsVariantParserRuleCall_4_0() { return cVariantsVariantParserRuleCall_4_0; }
		
		//( ";" variants+=variant ) *
		public Group getGroup_5() { return cGroup_5; }
		
		//";"
		public Keyword getSemicolonKeyword_5_0() { return cSemicolonKeyword_5_0; }
		
		//variants+=variant
		public Assignment getVariantsAssignment_5_1() { return cVariantsAssignment_5_1; }
		
		//variant
		public RuleCall getVariantsVariantParserRuleCall_5_1_0() { return cVariantsVariantParserRuleCall_5_1_0; }
	}
	public class Tag_fieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.tag_field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//tag_field:
		//    name=ID ":"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ":"
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}
	public class VariantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelsCase_label_listParserRuleCall_0_0 = (RuleCall)cLabelsAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFieldsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFieldsField_listParserRuleCall_3_0 = (RuleCall)cFieldsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//variant:
		//    labels=case_label_list ":" "(" fields=field_list? ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//labels=case_label_list ":" "(" fields=field_list? ")"
		public Group getGroup() { return cGroup; }
		
		//labels=case_label_list
		public Assignment getLabelsAssignment_0() { return cLabelsAssignment_0; }
		
		//case_label_list
		public RuleCall getLabelsCase_label_listParserRuleCall_0_0() { return cLabelsCase_label_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//fields=field_list?
		public Assignment getFieldsAssignment_3() { return cFieldsAssignment_3; }
		
		//field_list
		public RuleCall getFieldsField_listParserRuleCall_3_0() { return cFieldsField_listParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class Set_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.set_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//set_type:
		//    "set" "of" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"set" "of" type=type
		public Group getGroup() { return cGroup; }
		
		//"set"
		public Keyword getSetKeyword_0() { return cSetKeyword_0; }
		
		//"of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class File_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.file_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//file_type:
		//    "file" "of" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"file" "of" type=type
		public Group getGroup() { return cGroup; }
		
		//"file"
		public Keyword getFileKeyword_0() { return cFileKeyword_0; }
		
		//"of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class Pointer_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.pointer_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		//pointer_type: //TODO: CHANGED ID TO TYPE
		//    "^" type=type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: CHANGED ID TO TYPE
		//   "^" type=type
		public Group getGroup() { return cGroup; }
		
		////TODO: CHANGED ID TO TYPE
		//   "^"
		public Keyword getCircumflexAccentKeyword_0() { return cCircumflexAccentKeyword_0; }
		
		//type=type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }
	}
	public class Variable_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variable_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSectionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSectionsVariable_sectionParserRuleCall_1_0 = (RuleCall)cSectionsAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cSectionsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cSectionsVariable_sectionParserRuleCall_3_0_0 = (RuleCall)cSectionsAssignment_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//variable_declaration_part:
		//    "var" sections+=variable_section ";" ( sections+=variable_section ";" ) *
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"var" sections+=variable_section ";" ( sections+=variable_section ";" ) *
		public Group getGroup() { return cGroup; }
		
		//"var"
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//sections+=variable_section
		public Assignment getSectionsAssignment_1() { return cSectionsAssignment_1; }
		
		//variable_section
		public RuleCall getSectionsVariable_sectionParserRuleCall_1_0() { return cSectionsVariable_sectionParserRuleCall_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//( sections+=variable_section ";" ) *
		public Group getGroup_3() { return cGroup_3; }
		
		//sections+=variable_section
		public Assignment getSectionsAssignment_3_0() { return cSectionsAssignment_3_0; }
		
		//variable_section
		public RuleCall getSectionsVariable_sectionParserRuleCall_3_0_0() { return cSectionsVariable_sectionParserRuleCall_3_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_3_1() { return cSemicolonKeyword_3_1; }
	}
	public class Procedure_and_function_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.procedure_and_function_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cProceduresAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cProceduresProcedure_declarationParserRuleCall_0_0_0 = (RuleCall)cProceduresAssignment_0_0.eContents().get(0);
		private final Assignment cFunctionsAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cFunctionsFunction_declarationParserRuleCall_0_1_0 = (RuleCall)cFunctionsAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//procedure_and_function_declaration_part:
		//    ( ( procedures+=procedure_declaration | functions+=function_declaration  ) ";" ) +
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//( ( procedures+=procedure_declaration | functions+=function_declaration  ) ";" ) +
		public Group getGroup() { return cGroup; }
		
		//( procedures+=procedure_declaration | functions+=function_declaration  )
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//procedures+=procedure_declaration
		public Assignment getProceduresAssignment_0_0() { return cProceduresAssignment_0_0; }
		
		//procedure_declaration
		public RuleCall getProceduresProcedure_declarationParserRuleCall_0_0_0() { return cProceduresProcedure_declarationParserRuleCall_0_0_0; }
		
		//functions+=function_declaration
		public Assignment getFunctionsAssignment_0_1() { return cFunctionsAssignment_0_1; }
		
		//function_declaration
		public RuleCall getFunctionsFunction_declarationParserRuleCall_0_1_0() { return cFunctionsFunction_declarationParserRuleCall_0_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class Abstraction_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.abstraction_declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProcedure_declarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunction_declarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//abstraction_declaration:
		//    procedure_declaration | function_declaration
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//procedure_declaration | function_declaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//procedure_declaration
		public RuleCall getProcedure_declarationParserRuleCall_0() { return cProcedure_declarationParserRuleCall_0; }
		
		//function_declaration
		public RuleCall getFunction_declarationParserRuleCall_1() { return cFunction_declarationParserRuleCall_1; }
	}
	public class Abstraction_headingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.abstraction_heading");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProcedure_headingParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunction_headingParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//abstraction_heading:
		//    procedure_heading | function_heading
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//procedure_heading | function_heading
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//procedure_heading
		public RuleCall getProcedure_headingParserRuleCall_0() { return cProcedure_headingParserRuleCall_0; }
		
		//function_heading
		public RuleCall getFunction_headingParserRuleCall_1() { return cFunction_headingParserRuleCall_1; }
	}
	public class Procedure_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.procedure_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadingAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadingProcedure_headingParserRuleCall_0_0 = (RuleCall)cHeadingAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cBlockAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cBlockBlockParserRuleCall_2_0_0 = (RuleCall)cBlockAssignment_2_0.eContents().get(0);
		private final Assignment cForwardAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cForwardForwardKeyword_2_1_0 = (Keyword)cForwardAssignment_2_1.eContents().get(0);
		
		//procedure_declaration returns abstraction_heading:
		//    heading=procedure_heading ";" ( block=block | forward?="forward" )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//heading=procedure_heading ";" ( block=block | forward?="forward" )
		public Group getGroup() { return cGroup; }
		
		//heading=procedure_heading
		public Assignment getHeadingAssignment_0() { return cHeadingAssignment_0; }
		
		//procedure_heading
		public RuleCall getHeadingProcedure_headingParserRuleCall_0_0() { return cHeadingProcedure_headingParserRuleCall_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
		
		//( block=block | forward?="forward" )
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//block=block
		public Assignment getBlockAssignment_2_0() { return cBlockAssignment_2_0; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_2_0_0() { return cBlockBlockParserRuleCall_2_0_0; }
		
		//forward?="forward"
		public Assignment getForwardAssignment_2_1() { return cForwardAssignment_2_1; }
		
		//"forward"
		public Keyword getForwardForwardKeyword_2_1_0() { return cForwardForwardKeyword_2_1_0; }
	}
	public class Procedure_headingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.procedure_heading");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcedureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		
		//procedure_heading returns abstraction_heading:
		//    "procedure" name=ID ( parameters=formal_parameter_list ) ?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"procedure" name=ID ( parameters=formal_parameter_list ) ?
		public Group getGroup() { return cGroup; }
		
		//"procedure"
		public Keyword getProcedureKeyword_0() { return cProcedureKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//( parameters=formal_parameter_list ) ?
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getParametersFormal_parameter_listParserRuleCall_2_0() { return cParametersFormal_parameter_listParserRuleCall_2_0; }
	}
	public class Formal_parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.formal_parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParametersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParametersFormal_parameter_sectionParserRuleCall_1_0 = (RuleCall)cParametersAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersFormal_parameter_sectionParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//formal_parameter_list:
		//    "(" parameters+=formal_parameter_section ( ";" parameters+=formal_parameter_section ) * ")"
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"(" parameters+=formal_parameter_section ( ";" parameters+=formal_parameter_section ) * ")"
		public Group getGroup() { return cGroup; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//parameters+=formal_parameter_section
		public Assignment getParametersAssignment_1() { return cParametersAssignment_1; }
		
		//formal_parameter_section
		public RuleCall getParametersFormal_parameter_sectionParserRuleCall_1_0() { return cParametersFormal_parameter_sectionParserRuleCall_1_0; }
		
		//( ";" parameters+=formal_parameter_section ) *
		public Group getGroup_2() { return cGroup_2; }
		
		//";"
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//parameters+=formal_parameter_section
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }
		
		//formal_parameter_section
		public RuleCall getParametersFormal_parameter_sectionParserRuleCall_2_1_0() { return cParametersFormal_parameter_sectionParserRuleCall_2_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Formal_parameter_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.formal_parameter_section");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueValue_parameter_sectionParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cVariableVariable_parameter_sectionParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Assignment cProcedureAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cProcedureProcedure_headingParserRuleCall_2_0 = (RuleCall)cProcedureAssignment_2.eContents().get(0);
		private final Assignment cFunctionAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cFunctionFunction_headingParserRuleCall_3_0 = (RuleCall)cFunctionAssignment_3.eContents().get(0);
		
		//formal_parameter_section:
		//    value=value_parameter_section | variable=variable_parameter_section | procedure=procedure_heading | function=function_heading
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=value_parameter_section | variable=variable_parameter_section | procedure=procedure_heading | function=function_heading
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=value_parameter_section
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//value_parameter_section
		public RuleCall getValueValue_parameter_sectionParserRuleCall_0_0() { return cValueValue_parameter_sectionParserRuleCall_0_0; }
		
		//variable=variable_parameter_section
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//variable_parameter_section
		public RuleCall getVariableVariable_parameter_sectionParserRuleCall_1_0() { return cVariableVariable_parameter_sectionParserRuleCall_1_0; }
		
		//procedure=procedure_heading
		public Assignment getProcedureAssignment_2() { return cProcedureAssignment_2; }
		
		//procedure_heading
		public RuleCall getProcedureProcedure_headingParserRuleCall_2_0() { return cProcedureProcedure_headingParserRuleCall_2_0; }
		
		//function=function_heading
		public Assignment getFunctionAssignment_3() { return cFunctionAssignment_3; }
		
		//function_heading
		public RuleCall getFunctionFunction_headingParserRuleCall_3_0() { return cFunctionFunction_headingParserRuleCall_3_0; }
	}
	public class Value_parameter_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.value_parameter_section");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdentifiersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdentifiersIdentifier_listParserRuleCall_0_0 = (RuleCall)cIdentifiersAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeParameter_typeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//value_parameter_section:
		//    identifiers=identifier_list ":" type=parameter_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//identifiers=identifier_list ":" type=parameter_type
		public Group getGroup() { return cGroup; }
		
		//identifiers=identifier_list
		public Assignment getIdentifiersAssignment_0() { return cIdentifiersAssignment_0; }
		
		//identifier_list
		public RuleCall getIdentifiersIdentifier_listParserRuleCall_0_0() { return cIdentifiersIdentifier_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=parameter_type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//parameter_type
		public RuleCall getTypeParameter_typeParserRuleCall_2_0() { return cTypeParameter_typeParserRuleCall_2_0; }
	}
	public class Parameter_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.parameter_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cArrayAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cArrayConformant_array_schemaParserRuleCall_0_0 = (RuleCall)cArrayAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//parameter_type:
		//    array=conformant_array_schema | name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//array=conformant_array_schema | name=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//array=conformant_array_schema
		public Assignment getArrayAssignment_0() { return cArrayAssignment_0; }
		
		//conformant_array_schema
		public RuleCall getArrayConformant_array_schemaParserRuleCall_0_0() { return cArrayConformant_array_schemaParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class Conformant_array_schemaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.conformant_array_schema");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cPackedAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cPackedPacked_conformant_array_schemaParserRuleCall_0_0 = (RuleCall)cPackedAssignment_0.eContents().get(0);
		private final Assignment cUnpackedAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cUnpackedUnpacked_conformant_array_schemaParserRuleCall_1_0 = (RuleCall)cUnpackedAssignment_1.eContents().get(0);
		
		//conformant_array_schema:
		//    packed=packed_conformant_array_schema | unpacked=unpacked_conformant_array_schema
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//packed=packed_conformant_array_schema | unpacked=unpacked_conformant_array_schema
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//packed=packed_conformant_array_schema
		public Assignment getPackedAssignment_0() { return cPackedAssignment_0; }
		
		//packed_conformant_array_schema
		public RuleCall getPackedPacked_conformant_array_schemaParserRuleCall_0_0() { return cPackedPacked_conformant_array_schemaParserRuleCall_0_0; }
		
		//unpacked=unpacked_conformant_array_schema
		public Assignment getUnpackedAssignment_1() { return cUnpackedAssignment_1; }
		
		//unpacked_conformant_array_schema
		public RuleCall getUnpackedUnpacked_conformant_array_schemaParserRuleCall_1_0() { return cUnpackedUnpacked_conformant_array_schemaParserRuleCall_1_0; }
	}
	public class Packed_conformant_array_schemaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.packed_conformant_array_schema");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cArrayKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBoundBound_specificationParserRuleCall_3_0 = (RuleCall)cBoundAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cOfKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cNameAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cNameIDTerminalRuleCall_6_0 = (RuleCall)cNameAssignment_6.eContents().get(0);
		
		//packed_conformant_array_schema:
		//    "packed" "array" "[" bound=bound_specification "]" "of" name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"packed" "array" "[" bound=bound_specification "]" "of" name=ID
		public Group getGroup() { return cGroup; }
		
		//"packed"
		public Keyword getPackedKeyword_0() { return cPackedKeyword_0; }
		
		//"array"
		public Keyword getArrayKeyword_1() { return cArrayKeyword_1; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }
		
		//bound=bound_specification
		public Assignment getBoundAssignment_3() { return cBoundAssignment_3; }
		
		//bound_specification
		public RuleCall getBoundBound_specificationParserRuleCall_3_0() { return cBoundBound_specificationParserRuleCall_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//"of"
		public Keyword getOfKeyword_5() { return cOfKeyword_5; }
		
		//name=ID
		public Assignment getNameAssignment_6() { return cNameAssignment_6; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_6_0() { return cNameIDTerminalRuleCall_6_0; }
	}
	public class Bound_specificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.bound_specification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInitialAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInitialIDTerminalRuleCall_0_0 = (RuleCall)cInitialAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFinalAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFinalIDTerminalRuleCall_2_0 = (RuleCall)cFinalAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		
		//bound_specification:
		//    initial=ID ".." final=ID ":" name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//initial=ID ".." final=ID ":" name=ID
		public Group getGroup() { return cGroup; }
		
		//initial=ID
		public Assignment getInitialAssignment_0() { return cInitialAssignment_0; }
		
		//ID
		public RuleCall getInitialIDTerminalRuleCall_0_0() { return cInitialIDTerminalRuleCall_0_0; }
		
		//".."
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//final=ID
		public Assignment getFinalAssignment_2() { return cFinalAssignment_2; }
		
		//ID
		public RuleCall getFinalIDTerminalRuleCall_2_0() { return cFinalIDTerminalRuleCall_2_0; }
		
		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//name=ID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_4_0() { return cNameIDTerminalRuleCall_4_0; }
	}
	public class Unpacked_conformant_array_schemaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.unpacked_conformant_array_schema");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBoundsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBoundsBound_specificationParserRuleCall_2_0 = (RuleCall)cBoundsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cBoundsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cBoundsBound_specificationParserRuleCall_3_1_0 = (RuleCall)cBoundsAssignment_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cOfKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTypeParameter_typeParserRuleCall_6_0 = (RuleCall)cTypeAssignment_6.eContents().get(0);
		
		//unpacked_conformant_array_schema:
		//    "array" "[" bounds+=bound_specification ( ";" bounds+=bound_specification ) * "]" "of" type=parameter_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"array" "[" bounds+=bound_specification ( ";" bounds+=bound_specification ) * "]" "of" type=parameter_type
		public Group getGroup() { return cGroup; }
		
		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//bounds+=bound_specification
		public Assignment getBoundsAssignment_2() { return cBoundsAssignment_2; }
		
		//bound_specification
		public RuleCall getBoundsBound_specificationParserRuleCall_2_0() { return cBoundsBound_specificationParserRuleCall_2_0; }
		
		//( ";" bounds+=bound_specification ) *
		public Group getGroup_3() { return cGroup_3; }
		
		//";"
		public Keyword getSemicolonKeyword_3_0() { return cSemicolonKeyword_3_0; }
		
		//bounds+=bound_specification
		public Assignment getBoundsAssignment_3_1() { return cBoundsAssignment_3_1; }
		
		//bound_specification
		public RuleCall getBoundsBound_specificationParserRuleCall_3_1_0() { return cBoundsBound_specificationParserRuleCall_3_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//"of"
		public Keyword getOfKeyword_5() { return cOfKeyword_5; }
		
		//type=parameter_type
		public Assignment getTypeAssignment_6() { return cTypeAssignment_6; }
		
		//parameter_type
		public RuleCall getTypeParameter_typeParserRuleCall_6_0() { return cTypeParameter_typeParserRuleCall_6_0; }
	}
	public class Variable_parameter_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.variable_parameter_section");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifiersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifiersIdentifier_listParserRuleCall_1_0 = (RuleCall)cIdentifiersAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeParameter_typeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//variable_parameter_section:
		//    "var" identifiers=identifier_list ":" type=parameter_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"var" identifiers=identifier_list ":" type=parameter_type
		public Group getGroup() { return cGroup; }
		
		//"var"
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//identifiers=identifier_list
		public Assignment getIdentifiersAssignment_1() { return cIdentifiersAssignment_1; }
		
		//identifier_list
		public RuleCall getIdentifiersIdentifier_listParserRuleCall_1_0() { return cIdentifiersIdentifier_listParserRuleCall_1_0; }
		
		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=parameter_type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//parameter_type
		public RuleCall getTypeParameter_typeParserRuleCall_3_0() { return cTypeParameter_typeParserRuleCall_3_0; }
	}
	public class Function_headingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.function_heading");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cReturnTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cReturnTypeIDTerminalRuleCall_4_0 = (RuleCall)cReturnTypeAssignment_4.eContents().get(0);
		
		//function_heading returns abstraction_heading:
		//    "function" name=ID ( parameters=formal_parameter_list ) ? ":" returnType=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//"function" name=ID ( parameters=formal_parameter_list ) ? ":" returnType=ID
		public Group getGroup() { return cGroup; }
		
		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//( parameters=formal_parameter_list ) ?
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getParametersFormal_parameter_listParserRuleCall_2_0() { return cParametersFormal_parameter_listParserRuleCall_2_0; }
		
		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//returnType=ID
		public Assignment getReturnTypeAssignment_4() { return cReturnTypeAssignment_4; }
		
		//ID
		public RuleCall getReturnTypeIDTerminalRuleCall_4_0() { return cReturnTypeIDTerminalRuleCall_4_0; }
	}
	public class Function_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.function_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadingAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadingFunction_headingParserRuleCall_0_0 = (RuleCall)cHeadingAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cBlockAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cBlockBlockParserRuleCall_2_0_0 = (RuleCall)cBlockAssignment_2_0.eContents().get(0);
		private final Assignment cForwardAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cForwardForwardKeyword_2_1_0 = (Keyword)cForwardAssignment_2_1.eContents().get(0);
		
		//function_declaration returns abstraction_declaration:
		//    heading=function_heading ";" ( block=block | forward?="forward")
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//heading=function_heading ";" ( block=block | forward?="forward")
		public Group getGroup() { return cGroup; }
		
		//heading=function_heading
		public Assignment getHeadingAssignment_0() { return cHeadingAssignment_0; }
		
		//function_heading
		public RuleCall getHeadingFunction_headingParserRuleCall_0_0() { return cHeadingFunction_headingParserRuleCall_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
		
		//( block=block | forward?="forward")
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//block=block
		public Assignment getBlockAssignment_2_0() { return cBlockAssignment_2_0; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_2_0_0() { return cBlockBlockParserRuleCall_2_0_0; }
		
		//forward?="forward"
		public Assignment getForwardAssignment_2_1() { return cForwardAssignment_2_1; }
		
		//"forward"
		public Keyword getForwardForwardKeyword_2_1_0() { return cForwardForwardKeyword_2_1_0; }
	}
	
	
	private final PascalElements pPascal;
	private final ProgramElements pProgram;
	private final Program_heading_blockElements pProgram_heading_block;
	private final Identifier_listElements pIdentifier_list;
	private final BlockElements pBlock;
	private final Statement_partElements pStatement_part;
	private final Statement_sequenceElements pStatement_sequence;
	private final StatementElements pStatement;
	private final LabelElements pLabel;
	private final Simple_statementElements pSimple_statement;
	private final Assignment_statementElements pAssignment_statement;
	private final VariableElements pVariable;
	private final Var_Elements pVar_;
	private final Expression_listElements pExpression_list;
	private final ExpressionElements pExpression;
	private final Simple_expressionElements pSimple_expression;
	private final TermElements pTerm;
	private final FactorElements pFactor;
	private final NumberElements pNumber;
	private final Any_numberElements pAny_number;
	private final Unsigned_numberElements pUnsigned_number;
	private final Signed_numberElements pSigned_number;
	private final SetElements pSet;
	private final Function_designatorElements pFunction_designator;
	private final Structured_statementElements pStructured_statement;
	private final Compound_statementElements pCompound_statement;
	private final Repetitive_statementElements pRepetitive_statement;
	private final While_statementElements pWhile_statement;
	private final Repeat_statementElements pRepeat_statement;
	private final For_statementElements pFor_statement;
	private final Conditional_statementElements pConditional_statement;
	private final If_statementElements pIf_statement;
	private final Case_statementElements pCase_statement;
	private final Case_limbElements pCase_limb;
	private final Case_label_listElements pCase_label_list;
	private final ConstantElements pConstant;
	private final With_statementElements pWith_statement;
	private final Goto_statementElements pGoto_statement;
	private final Label_declaration_partElements pLabel_declaration_part;
	private final Constant_definition_partElements pConstant_definition_part;
	private final Constant_definitionElements pConstant_definition;
	private final Type_definition_partElements pType_definition_part;
	private final Type_definitionElements pType_definition;
	private final TypeElements pType;
	private final Simple_typeElements pSimple_type;
	private final Subrange_typeElements pSubrange_type;
	private final Enumerated_typeElements pEnumerated_type;
	private final Structured_typeElements pStructured_type;
	private final Unpacked_structured_typeElements pUnpacked_structured_type;
	private final Array_typeElements pArray_type;
	private final Dynamic_array_typeElements pDynamic_array_type;
	private final Index_typeElements pIndex_type;
	private final Record_typeElements pRecord_type;
	private final Field_listElements pField_list;
	private final Fixed_partElements pFixed_part;
	private final Variable_identifier_listElements pVariable_identifier_list;
	private final Variable_sectionElements pVariable_section;
	private final Record_sectionElements pRecord_section;
	private final Variant_partElements pVariant_part;
	private final Tag_fieldElements pTag_field;
	private final VariantElements pVariant;
	private final Set_typeElements pSet_type;
	private final File_typeElements pFile_type;
	private final Pointer_typeElements pPointer_type;
	private final Variable_declaration_partElements pVariable_declaration_part;
	private final Procedure_and_function_declaration_partElements pProcedure_and_function_declaration_part;
	private final Abstraction_declarationElements pAbstraction_declaration;
	private final Abstraction_headingElements pAbstraction_heading;
	private final Procedure_declarationElements pProcedure_declaration;
	private final Procedure_headingElements pProcedure_heading;
	private final Formal_parameter_listElements pFormal_parameter_list;
	private final Formal_parameter_sectionElements pFormal_parameter_section;
	private final Value_parameter_sectionElements pValue_parameter_section;
	private final Parameter_typeElements pParameter_type;
	private final Conformant_array_schemaElements pConformant_array_schema;
	private final Packed_conformant_array_schemaElements pPacked_conformant_array_schema;
	private final Bound_specificationElements pBound_specification;
	private final Unpacked_conformant_array_schemaElements pUnpacked_conformant_array_schema;
	private final Variable_parameter_sectionElements pVariable_parameter_section;
	private final Function_headingElements pFunction_heading;
	private final Function_declarationElements pFunction_declaration;
	private final TerminalRule tNUMERIC_SUBRANGE;
	private final TerminalRule tADDITION_OPERATOR;
	private final TerminalRule tMULTIPLICATION_OPERATOR;
	private final TerminalRule tRELATIONAL_OPERATOR;
	private final TerminalRule tSIGNED_INTEGER_NUMBER;
	private final TerminalRule tINTEGER_NUMBER;
	private final TerminalRule tSIGNED_REAL_NUMBER;
	private final TerminalRule tREAL_NUMBER;
	private final TerminalRule tUNSIGNED_DIGIT_SEQUENCE;
	private final TerminalRule tDIGIT_SEQUENCE;
	private final TerminalRule tDIGIT;
	private final TerminalRule tML_COMMENT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public DemoFkdGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pPascal = new PascalElements();
		this.pProgram = new ProgramElements();
		this.pProgram_heading_block = new Program_heading_blockElements();
		this.pIdentifier_list = new Identifier_listElements();
		this.pBlock = new BlockElements();
		this.pStatement_part = new Statement_partElements();
		this.pStatement_sequence = new Statement_sequenceElements();
		this.pStatement = new StatementElements();
		this.pLabel = new LabelElements();
		this.pSimple_statement = new Simple_statementElements();
		this.pAssignment_statement = new Assignment_statementElements();
		this.pVariable = new VariableElements();
		this.pVar_ = new Var_Elements();
		this.pExpression_list = new Expression_listElements();
		this.pExpression = new ExpressionElements();
		this.pSimple_expression = new Simple_expressionElements();
		this.pTerm = new TermElements();
		this.pFactor = new FactorElements();
		this.pNumber = new NumberElements();
		this.pAny_number = new Any_numberElements();
		this.pUnsigned_number = new Unsigned_numberElements();
		this.pSigned_number = new Signed_numberElements();
		this.pSet = new SetElements();
		this.pFunction_designator = new Function_designatorElements();
		this.pStructured_statement = new Structured_statementElements();
		this.pCompound_statement = new Compound_statementElements();
		this.pRepetitive_statement = new Repetitive_statementElements();
		this.pWhile_statement = new While_statementElements();
		this.pRepeat_statement = new Repeat_statementElements();
		this.pFor_statement = new For_statementElements();
		this.pConditional_statement = new Conditional_statementElements();
		this.pIf_statement = new If_statementElements();
		this.pCase_statement = new Case_statementElements();
		this.pCase_limb = new Case_limbElements();
		this.pCase_label_list = new Case_label_listElements();
		this.pConstant = new ConstantElements();
		this.pWith_statement = new With_statementElements();
		this.pGoto_statement = new Goto_statementElements();
		this.pLabel_declaration_part = new Label_declaration_partElements();
		this.pConstant_definition_part = new Constant_definition_partElements();
		this.pConstant_definition = new Constant_definitionElements();
		this.pType_definition_part = new Type_definition_partElements();
		this.pType_definition = new Type_definitionElements();
		this.pType = new TypeElements();
		this.pSimple_type = new Simple_typeElements();
		this.pSubrange_type = new Subrange_typeElements();
		this.pEnumerated_type = new Enumerated_typeElements();
		this.pStructured_type = new Structured_typeElements();
		this.pUnpacked_structured_type = new Unpacked_structured_typeElements();
		this.pArray_type = new Array_typeElements();
		this.pDynamic_array_type = new Dynamic_array_typeElements();
		this.pIndex_type = new Index_typeElements();
		this.pRecord_type = new Record_typeElements();
		this.pField_list = new Field_listElements();
		this.pFixed_part = new Fixed_partElements();
		this.pVariable_identifier_list = new Variable_identifier_listElements();
		this.pVariable_section = new Variable_sectionElements();
		this.pRecord_section = new Record_sectionElements();
		this.pVariant_part = new Variant_partElements();
		this.pTag_field = new Tag_fieldElements();
		this.pVariant = new VariantElements();
		this.pSet_type = new Set_typeElements();
		this.pFile_type = new File_typeElements();
		this.pPointer_type = new Pointer_typeElements();
		this.pVariable_declaration_part = new Variable_declaration_partElements();
		this.pProcedure_and_function_declaration_part = new Procedure_and_function_declaration_partElements();
		this.pAbstraction_declaration = new Abstraction_declarationElements();
		this.pAbstraction_heading = new Abstraction_headingElements();
		this.pProcedure_declaration = new Procedure_declarationElements();
		this.pProcedure_heading = new Procedure_headingElements();
		this.pFormal_parameter_list = new Formal_parameter_listElements();
		this.pFormal_parameter_section = new Formal_parameter_sectionElements();
		this.pValue_parameter_section = new Value_parameter_sectionElements();
		this.pParameter_type = new Parameter_typeElements();
		this.pConformant_array_schema = new Conformant_array_schemaElements();
		this.pPacked_conformant_array_schema = new Packed_conformant_array_schemaElements();
		this.pBound_specification = new Bound_specificationElements();
		this.pUnpacked_conformant_array_schema = new Unpacked_conformant_array_schemaElements();
		this.pVariable_parameter_section = new Variable_parameter_sectionElements();
		this.pFunction_heading = new Function_headingElements();
		this.pFunction_declaration = new Function_declarationElements();
		this.tNUMERIC_SUBRANGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.NUMERIC_SUBRANGE");
		this.tADDITION_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.ADDITION_OPERATOR");
		this.tMULTIPLICATION_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.MULTIPLICATION_OPERATOR");
		this.tRELATIONAL_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.RELATIONAL_OPERATOR");
		this.tSIGNED_INTEGER_NUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.SIGNED_INTEGER_NUMBER");
		this.tINTEGER_NUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.INTEGER_NUMBER");
		this.tSIGNED_REAL_NUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.SIGNED_REAL_NUMBER");
		this.tREAL_NUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.REAL_NUMBER");
		this.tUNSIGNED_DIGIT_SEQUENCE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.UNSIGNED_DIGIT_SEQUENCE");
		this.tDIGIT_SEQUENCE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.DIGIT_SEQUENCE");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.DIGIT");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.pascal.program.DemoFkd.ML_COMMENT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.pascal.program.DemoFkd".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//pascal:
	//    program += program
	//;
	public PascalElements getPascalAccess() {
		return pPascal;
	}
	
	public ParserRule getPascalRule() {
		return getPascalAccess().getRule();
	}
	
	//program:
	//    heading=program_heading_block block=block "."
	//;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//program_heading_block: //TODO: this parameter was added as optional
	//    "program" name=ID ( "(" identifiers=identifier_list ")" ) ? ";"
	//;
	public Program_heading_blockElements getProgram_heading_blockAccess() {
		return pProgram_heading_block;
	}
	
	public ParserRule getProgram_heading_blockRule() {
		return getProgram_heading_blockAccess().getRule();
	}
	
	//identifier_list:
	//    names+=ID ( "," names+=ID ) *
	//;
	public Identifier_listElements getIdentifier_listAccess() {
		return pIdentifier_list;
	}
	
	public ParserRule getIdentifier_listRule() {
		return getIdentifier_listAccess().getRule();
	}
	
	//block: //TODO: INLINE DECLARATION PART
	//    ( label=label_declaration_part ) ?
	//    ( constant=constant_definition_part ) ?
	//    ( type=type_definition_part ) ?
	//    ( variable=variable_declaration_part ) ?
	//    ( abstraction=procedure_and_function_declaration_part ) ?
	//    statement=statement_part
	//;
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//statement_part:
	//    "begin" sequence=statement_sequence "end"
	//;
	public Statement_partElements getStatement_partAccess() {
		return pStatement_part;
	}
	
	public ParserRule getStatement_partRule() {
		return getStatement_partAccess().getRule();
	}
	
	//statement_sequence:
	//    statements+=statement ( ";" statements+=statement ) *
	//;
	public Statement_sequenceElements getStatement_sequenceAccess() {
		return pStatement_sequence;
	}
	
	public ParserRule getStatement_sequenceRule() {
		return getStatement_sequenceAccess().getRule();
	}
	
	//statement:
	//    ( label=label ":" ) ? ( simple=simple_statement | structured=structured_statement )
	//;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//label:
	//    number=SIGNED_INTEGER_NUMBER | number=INTEGER_NUMBER
	//;
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}
	
	//simple_statement: //TODO: PARAMETER ID WAS ADDED (FUNCTION DESIGNATOR WITHOUT PARAMETER)
	//    ( assignment=assignment_statement | function=function_designator | goto=goto_statement | function_noargs=ID ) ?
	//;
	public Simple_statementElements getSimple_statementAccess() {
		return pSimple_statement;
	}
	
	public ParserRule getSimple_statementRule() {
		return getSimple_statementAccess().getRule();
	}
	
	//assignment_statement:
	//    variable=variable ":=" expression=expression
	//;
	public Assignment_statementElements getAssignment_statementAccess() {
		return pAssignment_statement;
	}
	
	public ParserRule getAssignment_statementRule() {
		return getAssignment_statementAccess().getRule();
	}
	
	//variable: //MISSING REFERENCED_VARIABLE BUT I THINK IT WORKS
	//    name=ID variable=var_
	//;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//var_: //TODO: REMOVED LEFT RECURSION (ERA COMPONENT_VARIABLE)
	//    ( "[" expressions=expression_list "]" array=var_ | accessor?="." name=ID variable=var_ | "^" pointer=var_ ) ?
	//;
	public Var_Elements getVar_Access() {
		return pVar_;
	}
	
	public ParserRule getVar_Rule() {
		return getVar_Access().getRule();
	}
	
	//expression_list:
	//    expressions+=expression ( "," expressions+=expression ) *
	//;
	public Expression_listElements getExpression_listAccess() {
		return pExpression_list;
	}
	
	public ParserRule getExpression_listRule() {
		return getExpression_listAccess().getRule();
	}
	
	//expression: //TODO: ADDED "=" PQ WAS NOT ACKNOWLEDGING IN RELATIONAL_OPERATOR
	//    expressions+=simple_expression ( ( operators+=RELATIONAL_OPERATOR | operators+="in" | operators+="=" ) expressions+=simple_expression ) ?
	//;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//simple_expression hidden(WS):
	//    ( prefixOperator=ADDITION_OPERATOR ) ? terms+=term ( ( operators+=ADDITION_OPERATOR | operators+="or" ) terms+=term | terms+=unsigned_number ) *
	//;
	public Simple_expressionElements getSimple_expressionAccess() {
		return pSimple_expression;
	}
	
	public ParserRule getSimple_expressionRule() {
		return getSimple_expressionAccess().getRule();
	}
	
	//term:
	//    factors+=factor ( ( operators+=MULTIPLICATION_OPERATOR | operators+="div" | operators+="mod" | operators+="and" ) factors+=factor ) *
	//;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//factor:
	//    variable=variable | number=number | string=STRING | set=set | nil?="nil" | boolean="true" | boolean="false" | function=function_designator | "(" expression=expression ")" | "not" not=factor
	//;
	public FactorElements getFactorAccess() {
		return pFactor;
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}
	
	//number:
	//    number=any_number
	//;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//any_number:
	//    unsigned_number | signed_number
	//;
	public Any_numberElements getAny_numberAccess() {
		return pAny_number;
	}
	
	public ParserRule getAny_numberRule() {
		return getAny_numberAccess().getRule();
	}
	
	//unsigned_number returns any_number:
	//    integer=INTEGER_NUMBER | real=REAL_NUMBER
	//;
	public Unsigned_numberElements getUnsigned_numberAccess() {
		return pUnsigned_number;
	}
	
	public ParserRule getUnsigned_numberRule() {
		return getUnsigned_numberAccess().getRule();
	}
	
	//signed_number returns any_number:
	//    integer=SIGNED_INTEGER_NUMBER | real=SIGNED_REAL_NUMBER
	//;
	public Signed_numberElements getSigned_numberAccess() {
		return pSigned_number;
	}
	
	public ParserRule getSigned_numberRule() {
		return getSigned_numberAccess().getRule();
	}
	
	//set:
	//    brackets+="[" expressions=expression_list ? brackets+="]"
	//;
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}
	
	//function_designator:
	//    name=ID "(" expressions=expression_list ? ")"
	//;
	public Function_designatorElements getFunction_designatorAccess() {
		return pFunction_designator;
	}
	
	public ParserRule getFunction_designatorRule() {
		return getFunction_designatorAccess().getRule();
	}
	
	//structured_statement:
	//    compound=compound_statement | repetitive=repetitive_statement | conditional=conditional_statement | withStmt=with_statement
	//;
	public Structured_statementElements getStructured_statementAccess() {
		return pStructured_statement;
	}
	
	public ParserRule getStructured_statementRule() {
		return getStructured_statementAccess().getRule();
	}
	
	//compound_statement:
	//    "begin" sequence=statement_sequence "end"
	//;
	public Compound_statementElements getCompound_statementAccess() {
		return pCompound_statement;
	}
	
	public ParserRule getCompound_statementRule() {
		return getCompound_statementAccess().getRule();
	}
	
	//repetitive_statement:
	//    whileStmt=while_statement | repeatStmt=repeat_statement | forStmt=for_statement
	//;
	public Repetitive_statementElements getRepetitive_statementAccess() {
		return pRepetitive_statement;
	}
	
	public ParserRule getRepetitive_statementRule() {
		return getRepetitive_statementAccess().getRule();
	}
	
	//while_statement:
	//    "while" expression=expression "do" statement=statement
	//;
	public While_statementElements getWhile_statementAccess() {
		return pWhile_statement;
	}
	
	public ParserRule getWhile_statementRule() {
		return getWhile_statementAccess().getRule();
	}
	
	//repeat_statement:
	//    "repeat" sequence=statement_sequence "until" expression=expression
	//;
	public Repeat_statementElements getRepeat_statementAccess() {
		return pRepeat_statement;
	}
	
	public ParserRule getRepeat_statementRule() {
		return getRepeat_statementAccess().getRule();
	}
	
	//for_statement:
	//    "for" assignment=assignment_statement ( "to" | "downto" ) expression=expression "do" statement=statement
	//;
	public For_statementElements getFor_statementAccess() {
		return pFor_statement;
	}
	
	public ParserRule getFor_statementRule() {
		return getFor_statementAccess().getRule();
	}
	
	//conditional_statement:
	//    ifStmt=if_statement | caseStmt=case_statement
	//;
	public Conditional_statementElements getConditional_statementAccess() {
		return pConditional_statement;
	}
	
	public ParserRule getConditional_statementRule() {
		return getConditional_statementAccess().getRule();
	}
	
	//if_statement:
	//    "if" expression=expression "then" ifStatement=statement ( "else" elseStatement=statement )    ?
	//;
	public If_statementElements getIf_statementAccess() {
		return pIf_statement;
	}
	
	public ParserRule getIf_statementRule() {
		return getIf_statementAccess().getRule();
	}
	
	//case_statement:
	//    "case" expression=expression "of" cases+=case_limb ( ";" cases+=case_limb ) * ( ";" ) ? "end"
	//;
	public Case_statementElements getCase_statementAccess() {
		return pCase_statement;
	}
	
	public ParserRule getCase_statementRule() {
		return getCase_statementAccess().getRule();
	}
	
	//case_limb:
	//    cases=case_label_list ":" statement=statement
	//;
	public Case_limbElements getCase_limbAccess() {
		return pCase_limb;
	}
	
	public ParserRule getCase_limbRule() {
		return getCase_limbAccess().getRule();
	}
	
	//case_label_list:
	//    constants+=constant ( "," constants+=constant ) *
	//;
	public Case_label_listElements getCase_label_listAccess() {
		return pCase_label_list;
	}
	
	public ParserRule getCase_label_listRule() {
		return getCase_label_listAccess().getRule();
	}
	
	//constant:
	//    opterator=ADDITION_OPERATOR ? ( name=ID | number=number ) | string=STRING | boolLiteral="true" | boolLiteral="false" | nil="nil"
	//;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//with_statement:
	//    "with" variables+=variable ( "," variables+=variable ) * "do" statement=statement
	//;
	public With_statementElements getWith_statementAccess() {
		return pWith_statement;
	}
	
	public ParserRule getWith_statementRule() {
		return getWith_statementAccess().getRule();
	}
	
	//goto_statement:
	//    "goto" label=label
	//;
	public Goto_statementElements getGoto_statementAccess() {
		return pGoto_statement;
	}
	
	public ParserRule getGoto_statementRule() {
		return getGoto_statementAccess().getRule();
	}
	
	//label_declaration_part:
	//    "label" labels+=label ( "," labels+=label ) * ";"
	//;
	public Label_declaration_partElements getLabel_declaration_partAccess() {
		return pLabel_declaration_part;
	}
	
	public ParserRule getLabel_declaration_partRule() {
		return getLabel_declaration_partAccess().getRule();
	}
	
	//constant_definition_part:
	//    "const" ( consts+=constant_definition ";" ) +
	//;
	public Constant_definition_partElements getConstant_definition_partAccess() {
		return pConstant_definition_part;
	}
	
	public ParserRule getConstant_definition_partRule() {
		return getConstant_definition_partAccess().getRule();
	}
	
	//constant_definition:
	//    name=ID "=" const=constant
	//;
	public Constant_definitionElements getConstant_definitionAccess() {
		return pConstant_definition;
	}
	
	public ParserRule getConstant_definitionRule() {
		return getConstant_definitionAccess().getRule();
	}
	
	//type_definition_part:
	//    "type" ( types+=type_definition ";" ) +
	//;
	public Type_definition_partElements getType_definition_partAccess() {
		return pType_definition_part;
	}
	
	public ParserRule getType_definition_partRule() {
		return getType_definition_partAccess().getRule();
	}
	
	//type_definition:
	//    name=ID "=" type=type
	//;
	public Type_definitionElements getType_definitionAccess() {
		return pType_definition;
	}
	
	public ParserRule getType_definitionRule() {
		return getType_definitionAccess().getRule();
	}
	
	//type: //TODO: REMOVED ID
	//    simple=simple_type | structured=structured_type | pointer=pointer_type
	//;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//simple_type: //TODO: ADDED ID
	//    subrange=subrange_type | enumerated=enumerated_type | name=ID
	//;
	public Simple_typeElements getSimple_typeAccess() {
		return pSimple_type;
	}
	
	public ParserRule getSimple_typeRule() {
		return getSimple_typeAccess().getRule();
	}
	
	//subrange_type hidden(WS): //TODO: ADDED HIDDEN(WS) TO REMOVE BLANK SPACE
	//     initialConst=constant ".." finalConst=constant | subrange=NUMERIC_SUBRANGE const=constant
	//;
	public Subrange_typeElements getSubrange_typeAccess() {
		return pSubrange_type;
	}
	
	public ParserRule getSubrange_typeRule() {
		return getSubrange_typeAccess().getRule();
	}
	
	//enumerated_type:
	//    "(" identifiers=identifier_list ")"
	//;
	public Enumerated_typeElements getEnumerated_typeAccess() {
		return pEnumerated_type;
	}
	
	public ParserRule getEnumerated_typeRule() {
		return getEnumerated_typeAccess().getRule();
	}
	
	//structured_type:
	//    ( packed?="packed" ) ? type=unpacked_structured_type
	//;
	public Structured_typeElements getStructured_typeAccess() {
		return pStructured_type;
	}
	
	public ParserRule getStructured_typeRule() {
		return getStructured_typeAccess().getRule();
	}
	
	//unpacked_structured_type: //TODO: ADDED DYNAMIC_ARRAY_TYPE
	//    array=array_type | dynamic=dynamic_array_type | record=record_type | set=set_type | file=file_type
	//;
	public Unpacked_structured_typeElements getUnpacked_structured_typeAccess() {
		return pUnpacked_structured_type;
	}
	
	public ParserRule getUnpacked_structured_typeRule() {
		return getUnpacked_structured_typeAccess().getRule();
	}
	
	//array_type:
	//    "array" "[" indexes+=index_type ( "," indexes+=index_type ) * "]" "of" type=type
	//;
	public Array_typeElements getArray_typeAccess() {
		return pArray_type;
	}
	
	public ParserRule getArray_typeRule() {
		return getArray_typeAccess().getRule();
	}
	
	//dynamic_array_type:
	//    "array" "of" type=type
	//;
	public Dynamic_array_typeElements getDynamic_array_typeAccess() {
		return pDynamic_array_type;
	}
	
	public ParserRule getDynamic_array_typeRule() {
		return getDynamic_array_typeAccess().getRule();
	}
	
	//index_type:
	//    type=simple_type
	//;
	public Index_typeElements getIndex_typeAccess() {
		return pIndex_type;
	}
	
	public ParserRule getIndex_typeRule() {
		return getIndex_typeAccess().getRule();
	}
	
	//record_type:
	//    recordKeyword="record" fields=field_list? endKeyword="end"
	//;
	public Record_typeElements getRecord_typeAccess() {
		return pRecord_type;
	}
	
	public ParserRule getRecord_typeRule() {
		return getRecord_typeAccess().getRule();
	}
	
	//field_list:
	//    ( fixed=fixed_part ( ";" variants+=variant_part ) ? | variants+=variant_part ) ( ";" ) ?
	//;
	public Field_listElements getField_listAccess() {
		return pField_list;
	}
	
	public ParserRule getField_listRule() {
		return getField_listAccess().getRule();
	}
	
	//fixed_part:
	//    sections+=record_section ( ";" sections+=record_section ) *
	//;
	public Fixed_partElements getFixed_partAccess() {
		return pFixed_part;
	}
	
	public ParserRule getFixed_partRule() {
		return getFixed_partAccess().getRule();
	}
	
	//variable_identifier_list:
	//    names+=ID ( "," names+=ID ) *
	//;
	public Variable_identifier_listElements getVariable_identifier_listAccess() {
		return pVariable_identifier_list;
	}
	
	public ParserRule getVariable_identifier_listRule() {
		return getVariable_identifier_listAccess().getRule();
	}
	
	//variable_section:
	//    identifiers=variable_identifier_list ":" type=type
	//;
	public Variable_sectionElements getVariable_sectionAccess() {
		return pVariable_section;
	}
	
	public ParserRule getVariable_sectionRule() {
		return getVariable_sectionAccess().getRule();
	}
	
	//record_section:
	//    identifiers=identifier_list ":" type=type
	//;
	public Record_sectionElements getRecord_sectionAccess() {
		return pRecord_section;
	}
	
	public ParserRule getRecord_sectionRule() {
		return getRecord_sectionAccess().getRule();
	}
	
	//variant_part:
	//    "case" tag=tag_field? name=ID "of" variants+=variant ( ";" variants+=variant ) *
	//;
	public Variant_partElements getVariant_partAccess() {
		return pVariant_part;
	}
	
	public ParserRule getVariant_partRule() {
		return getVariant_partAccess().getRule();
	}
	
	//tag_field:
	//    name=ID ":"
	//;
	public Tag_fieldElements getTag_fieldAccess() {
		return pTag_field;
	}
	
	public ParserRule getTag_fieldRule() {
		return getTag_fieldAccess().getRule();
	}
	
	//variant:
	//    labels=case_label_list ":" "(" fields=field_list? ")"
	//;
	public VariantElements getVariantAccess() {
		return pVariant;
	}
	
	public ParserRule getVariantRule() {
		return getVariantAccess().getRule();
	}
	
	//set_type:
	//    "set" "of" type=type
	//;
	public Set_typeElements getSet_typeAccess() {
		return pSet_type;
	}
	
	public ParserRule getSet_typeRule() {
		return getSet_typeAccess().getRule();
	}
	
	//file_type:
	//    "file" "of" type=type
	//;
	public File_typeElements getFile_typeAccess() {
		return pFile_type;
	}
	
	public ParserRule getFile_typeRule() {
		return getFile_typeAccess().getRule();
	}
	
	//pointer_type: //TODO: CHANGED ID TO TYPE
	//    "^" type=type
	//;
	public Pointer_typeElements getPointer_typeAccess() {
		return pPointer_type;
	}
	
	public ParserRule getPointer_typeRule() {
		return getPointer_typeAccess().getRule();
	}
	
	//variable_declaration_part:
	//    "var" sections+=variable_section ";" ( sections+=variable_section ";" ) *
	//;
	public Variable_declaration_partElements getVariable_declaration_partAccess() {
		return pVariable_declaration_part;
	}
	
	public ParserRule getVariable_declaration_partRule() {
		return getVariable_declaration_partAccess().getRule();
	}
	
	//procedure_and_function_declaration_part:
	//    ( ( procedures+=procedure_declaration | functions+=function_declaration  ) ";" ) +
	//;
	public Procedure_and_function_declaration_partElements getProcedure_and_function_declaration_partAccess() {
		return pProcedure_and_function_declaration_part;
	}
	
	public ParserRule getProcedure_and_function_declaration_partRule() {
		return getProcedure_and_function_declaration_partAccess().getRule();
	}
	
	//abstraction_declaration:
	//    procedure_declaration | function_declaration
	//;
	public Abstraction_declarationElements getAbstraction_declarationAccess() {
		return pAbstraction_declaration;
	}
	
	public ParserRule getAbstraction_declarationRule() {
		return getAbstraction_declarationAccess().getRule();
	}
	
	//abstraction_heading:
	//    procedure_heading | function_heading
	//;
	public Abstraction_headingElements getAbstraction_headingAccess() {
		return pAbstraction_heading;
	}
	
	public ParserRule getAbstraction_headingRule() {
		return getAbstraction_headingAccess().getRule();
	}
	
	//procedure_declaration returns abstraction_heading:
	//    heading=procedure_heading ";" ( block=block | forward?="forward" )
	//;
	public Procedure_declarationElements getProcedure_declarationAccess() {
		return pProcedure_declaration;
	}
	
	public ParserRule getProcedure_declarationRule() {
		return getProcedure_declarationAccess().getRule();
	}
	
	//procedure_heading returns abstraction_heading:
	//    "procedure" name=ID ( parameters=formal_parameter_list ) ?
	//;
	public Procedure_headingElements getProcedure_headingAccess() {
		return pProcedure_heading;
	}
	
	public ParserRule getProcedure_headingRule() {
		return getProcedure_headingAccess().getRule();
	}
	
	//formal_parameter_list:
	//    "(" parameters+=formal_parameter_section ( ";" parameters+=formal_parameter_section ) * ")"
	//;
	public Formal_parameter_listElements getFormal_parameter_listAccess() {
		return pFormal_parameter_list;
	}
	
	public ParserRule getFormal_parameter_listRule() {
		return getFormal_parameter_listAccess().getRule();
	}
	
	//formal_parameter_section:
	//    value=value_parameter_section | variable=variable_parameter_section | procedure=procedure_heading | function=function_heading
	//;
	public Formal_parameter_sectionElements getFormal_parameter_sectionAccess() {
		return pFormal_parameter_section;
	}
	
	public ParserRule getFormal_parameter_sectionRule() {
		return getFormal_parameter_sectionAccess().getRule();
	}
	
	//value_parameter_section:
	//    identifiers=identifier_list ":" type=parameter_type
	//;
	public Value_parameter_sectionElements getValue_parameter_sectionAccess() {
		return pValue_parameter_section;
	}
	
	public ParserRule getValue_parameter_sectionRule() {
		return getValue_parameter_sectionAccess().getRule();
	}
	
	//parameter_type:
	//    array=conformant_array_schema | name=ID
	//;
	public Parameter_typeElements getParameter_typeAccess() {
		return pParameter_type;
	}
	
	public ParserRule getParameter_typeRule() {
		return getParameter_typeAccess().getRule();
	}
	
	//conformant_array_schema:
	//    packed=packed_conformant_array_schema | unpacked=unpacked_conformant_array_schema
	//;
	public Conformant_array_schemaElements getConformant_array_schemaAccess() {
		return pConformant_array_schema;
	}
	
	public ParserRule getConformant_array_schemaRule() {
		return getConformant_array_schemaAccess().getRule();
	}
	
	//packed_conformant_array_schema:
	//    "packed" "array" "[" bound=bound_specification "]" "of" name=ID
	//;
	public Packed_conformant_array_schemaElements getPacked_conformant_array_schemaAccess() {
		return pPacked_conformant_array_schema;
	}
	
	public ParserRule getPacked_conformant_array_schemaRule() {
		return getPacked_conformant_array_schemaAccess().getRule();
	}
	
	//bound_specification:
	//    initial=ID ".." final=ID ":" name=ID
	//;
	public Bound_specificationElements getBound_specificationAccess() {
		return pBound_specification;
	}
	
	public ParserRule getBound_specificationRule() {
		return getBound_specificationAccess().getRule();
	}
	
	//unpacked_conformant_array_schema:
	//    "array" "[" bounds+=bound_specification ( ";" bounds+=bound_specification ) * "]" "of" type=parameter_type
	//;
	public Unpacked_conformant_array_schemaElements getUnpacked_conformant_array_schemaAccess() {
		return pUnpacked_conformant_array_schema;
	}
	
	public ParserRule getUnpacked_conformant_array_schemaRule() {
		return getUnpacked_conformant_array_schemaAccess().getRule();
	}
	
	//variable_parameter_section:
	//    "var" identifiers=identifier_list ":" type=parameter_type
	//;
	public Variable_parameter_sectionElements getVariable_parameter_sectionAccess() {
		return pVariable_parameter_section;
	}
	
	public ParserRule getVariable_parameter_sectionRule() {
		return getVariable_parameter_sectionAccess().getRule();
	}
	
	//function_heading returns abstraction_heading:
	//    "function" name=ID ( parameters=formal_parameter_list ) ? ":" returnType=ID
	//;
	public Function_headingElements getFunction_headingAccess() {
		return pFunction_heading;
	}
	
	public ParserRule getFunction_headingRule() {
		return getFunction_headingAccess().getRule();
	}
	
	//function_declaration returns abstraction_declaration:
	//    heading=function_heading ";" ( block=block | forward?="forward")
	//;
	public Function_declarationElements getFunction_declarationAccess() {
		return pFunction_declaration;
	}
	
	public ParserRule getFunction_declarationRule() {
		return getFunction_declarationAccess().getRule();
	}
	
	//terminal NUMERIC_SUBRANGE:
	//    ( INTEGER_NUMBER | REAL_NUMBER | SIGNED_INTEGER_NUMBER | SIGNED_REAL_NUMBER ) ".."
	//;
	public TerminalRule getNUMERIC_SUBRANGERule() {
		return tNUMERIC_SUBRANGE;
	}
	
	//terminal ADDITION_OPERATOR:
	//    "+" | "-"
	//;
	public TerminalRule getADDITION_OPERATORRule() {
		return tADDITION_OPERATOR;
	}
	
	//terminal MULTIPLICATION_OPERATOR:
	//    "*" | "/"
	//;
	public TerminalRule getMULTIPLICATION_OPERATORRule() {
		return tMULTIPLICATION_OPERATOR;
	}
	
	//terminal RELATIONAL_OPERATOR:
	//    "=" | "<>" | "<" | "<=" | ">" | ">="
	//;
	public TerminalRule getRELATIONAL_OPERATORRule() {
		return tRELATIONAL_OPERATOR;
	}
	
	//terminal SIGNED_INTEGER_NUMBER:
	//    ADDITION_OPERATOR INTEGER_NUMBER
	//;
	public TerminalRule getSIGNED_INTEGER_NUMBERRule() {
		return tSIGNED_INTEGER_NUMBER;
	}
	
	//terminal INTEGER_NUMBER:
	//    UNSIGNED_DIGIT_SEQUENCE
	//;
	public TerminalRule getINTEGER_NUMBERRule() {
		return tINTEGER_NUMBER;
	}
	
	//terminal SIGNED_REAL_NUMBER:
	//    ADDITION_OPERATOR REAL_NUMBER
	//;
	public TerminalRule getSIGNED_REAL_NUMBERRule() {
		return tSIGNED_REAL_NUMBER;
	}
	
	//terminal REAL_NUMBER:
	//    UNSIGNED_DIGIT_SEQUENCE "." ( UNSIGNED_DIGIT_SEQUENCE ) ? ( ( "E" | "e" ) DIGIT_SEQUENCE ) ? |
	//    UNSIGNED_DIGIT_SEQUENCE ( "E" | "e" ) DIGIT_SEQUENCE
	//;
	public TerminalRule getREAL_NUMBERRule() {
		return tREAL_NUMBER;
	}
	
	//terminal UNSIGNED_DIGIT_SEQUENCE:
	//    DIGIT+
	//;
	public TerminalRule getUNSIGNED_DIGIT_SEQUENCERule() {
		return tUNSIGNED_DIGIT_SEQUENCE;
	}
	
	//terminal DIGIT_SEQUENCE:
	//    ADDITION_OPERATOR ? UNSIGNED_DIGIT_SEQUENCE
	//;
	public TerminalRule getDIGIT_SEQUENCERule() {
		return tDIGIT_SEQUENCE;
	}
	
	//terminal DIGIT:
	//    "0".."9"
	//;
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal ML_COMMENT : '(*' -> '*)' | '{' -> '}';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
